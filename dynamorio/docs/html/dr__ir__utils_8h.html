<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>DynamoRIO API: dr_ir_utils.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO API
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dr__ir__utils_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dr_ir_utils.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Code transformation utilities.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a85e6559244f2fc5b84c7a07f04168bad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a85e6559244f2fc5b84c7a07f04168bad">SPILL_SLOT_REDIRECT_NATIVE_TGT</a>&#160;&#160;&#160;SPILL_SLOT_1</td></tr>
<tr class="separator:a85e6559244f2fc5b84c7a07f04168bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a89a6b714ff24d91d78589877047a29b9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> { , <br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9ae4cd78beccb2525acc61f2536ba1ea71">SPILL_SLOT_2</a> = 1, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a446ae7a7df24d2c3abae567a17289566">SPILL_SLOT_3</a> = 2, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9ab1b97fb0822126941b211160965034e4">SPILL_SLOT_4</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a57734b157aa48d5db278cb1aa372cd56">SPILL_SLOT_5</a> = 4, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9ac4c22f3fdbacb7b37b55484b5577f1e0">SPILL_SLOT_6</a> = 5, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9abbff886ccbde7dc9ce9bd4e379eb7ac3">SPILL_SLOT_7</a> = 6, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a6bbd68ecb5a36a22f247c5806fa5fec9">SPILL_SLOT_8</a> = 7, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9aa1bffc7b66f58d71b52284c0f49d5a53">SPILL_SLOT_9</a> = 8, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a44005b876b8364b0433f880f5b9b1a68">SPILL_SLOT_10</a> = 9, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a78ba623c508dc9db382bd16205e862c5">SPILL_SLOT_11</a> = 10, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a3bd3a0c1a09dd08a8cf3cdc99902767a">SPILL_SLOT_12</a> = 11, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a2a009fac1a98d5546313cb17b0a026a7">SPILL_SLOT_13</a> = 12, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9ace6bda60e6d81dc4914384f28d2e159e">SPILL_SLOT_14</a> = 13, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a529c3a41f0f3324929310b94915de96e">SPILL_SLOT_15</a> = 14, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a3d4436b445175a7088cd958a7e81f9b8">SPILL_SLOT_16</a> = 15, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a8483a4f53a6c380d0356a0596745ce09">SPILL_SLOT_17</a> = 16, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9a794503b196c55da22002fc15549916fa">SPILL_SLOT_MAX</a> = SPILL_SLOT_17
<br/>
 }</td></tr>
<tr class="separator:a89a6b714ff24d91d78589877047a29b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b1bc23c42ffb7452568176b09b1212"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212">dr_cleancall_save_t</a> { <br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212ac04fbaff072a9ec162172cdd8305080d">DR_CLEANCALL_SAVE_FLOAT</a> = 0x0001, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212a2b03fe8506703bdcc4c24c49f6f16915">DR_CLEANCALL_NOSAVE_FLAGS</a> = 0x0002, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212abde57f92afb00d994bc1ea596ba31306">DR_CLEANCALL_NOSAVE_XMM</a> = 0x0004, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212a04d3bcbf34926384e13d48d45aa42d2a">DR_CLEANCALL_NOSAVE_XMM_NONPARAM</a> = 0x0008, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212a658cc567c0e4c91c0a065a17cb7ba5ed">DR_CLEANCALL_NOSAVE_XMM_NONRET</a> = 0x0010, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212a9fe53fc77afb460ba31666995df5b6c9">DR_CLEANCALL_INDIRECT</a> = 0x0020
<br/>
 }</td></tr>
<tr class="separator:af1b1bc23c42ffb7452568176b09b1212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1e2fa2049719870ad0c1007b00d4e3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3">dr_disasm_flags_t</a> { <br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3af82d1bee9aa93ac6df451bd80a4b1278">DR_DISASM_DR</a> = 0x0, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3a406704bf086c0d17c5bfade619533835">DR_DISASM_INTEL</a> = 0x1, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3a83d3ece1134b8dabc7f0fd2f84185f11">DR_DISASM_ATT</a> = 0x2, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3aa9e5caa6773c8f8a4ff13b77231dbdaf">DR_DISASM_STRICT_INVALID</a> = 0x4, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3a4371407d86fde325673f7d3967037708">DR_DISASM_NO_OPND_SIZE</a> = 0x8
<br/>
 }</td></tr>
<tr class="separator:a4c1e2fa2049719870ad0c1007b00d4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adf9a4f63eafc7f9725f7d5bf1725ab5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#adf9a4f63eafc7f9725f7d5bf1725ab5c">set_x86_mode</a> (void *drcontext, bool x86)</td></tr>
<tr class="separator:adf9a4f63eafc7f9725f7d5bf1725ab5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18c8ca0720c97403a0fa9371ae792e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#aa18c8ca0720c97403a0fa9371ae792e5">get_x86_mode</a> (void *drcontext)</td></tr>
<tr class="separator:aa18c8ca0720c97403a0fa9371ae792e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af294ac021c84f5ec47230ee7df0e6c02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr class="separator:af294ac021c84f5ec47230ee7df0e6c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453bc3ecddb4298ffdc1c429f30881b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr class="separator:a453bc3ecddb4298ffdc1c429f30881b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762389f8ae9d809fd7b8f1418cdbd5ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot</a> (void)</td></tr>
<tr class="separator:a762389f8ae9d809fd7b8f1418cdbd5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eab608c134db044f2d9453a8407d470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a5eab608c134db044f2d9453a8407d470">dr_reg_spill_slot_opnd</a> (void *drcontext, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr class="separator:a5eab608c134db044f2d9453a8407d470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb63ecfaa5256688bab9a2921fc19227"><td class="memItemLeft" align="right" valign="top">reg_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#abb63ecfaa5256688bab9a2921fc19227">dr_read_saved_reg</a> (void *drcontext, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr class="separator:abb63ecfaa5256688bab9a2921fc19227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8d50d718883a1caf6a2de0fb3dbce3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#abf8d50d718883a1caf6a2de0fb3dbce3">dr_write_saved_reg</a> (void *drcontext, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot, reg_t value)</td></tr>
<tr class="separator:abf8d50d718883a1caf6a2de0fb3dbce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44636ca6809a9fb22cf817701de9ee09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a44636ca6809a9fb22cf817701de9ee09">dr_save_arith_flags</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr class="separator:a44636ca6809a9fb22cf817701de9ee09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563b0de37a51cb2e84337deef30a57cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a563b0de37a51cb2e84337deef30a57cf">dr_restore_arith_flags</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> slot)</td></tr>
<tr class="separator:a563b0de37a51cb2e84337deef30a57cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbf1b9557d56d555bbdaae525b0992d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a0cbf1b9557d56d555bbdaae525b0992d">dr_save_arith_flags_to_xax</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr class="separator:a0cbf1b9557d56d555bbdaae525b0992d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69b4cb9ffac510fbfceab08472de13e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ab69b4cb9ffac510fbfceab08472de13e">dr_restore_arith_flags_from_xax</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr class="separator:ab69b4cb9ffac510fbfceab08472de13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3831354cc7402d68719d8055fb3e9931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a3831354cc7402d68719d8055fb3e9931">dr_insert_read_tls_field</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg)</td></tr>
<tr class="separator:a3831354cc7402d68719d8055fb3e9931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982089284bd51339f448ec4b3928d3b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a982089284bd51339f448ec4b3928d3b4">dr_insert_write_tls_field</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, reg_id_t reg)</td></tr>
<tr class="separator:a982089284bd51339f448ec4b3928d3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0b7e9e09a9a85ca1a707da3ded6f69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a3b0b7e9e09a9a85ca1a707da3ded6f69">instrlist_meta_preinsert</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a3b0b7e9e09a9a85ca1a707da3ded6f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98218650e1f61b58c5478cf68e25d9da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a98218650e1f61b58c5478cf68e25d9da">instrlist_meta_postinsert</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a98218650e1f61b58c5478cf68e25d9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824eaa9075a7aaf443b4cc4180eec81e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a824eaa9075a7aaf443b4cc4180eec81e">instrlist_meta_append</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a824eaa9075a7aaf443b4cc4180eec81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe811040a2962e5c6920a3c523212ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#affe811040a2962e5c6920a3c523212ab">instrlist_meta_fault_preinsert</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:affe811040a2962e5c6920a3c523212ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea095671bab4239c659d17d4a9cda56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a6ea095671bab4239c659d17d4a9cda56">instrlist_meta_fault_postinsert</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a6ea095671bab4239c659d17d4a9cda56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a1526c7b520c9aefbd775adfc57108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a94a1526c7b520c9aefbd775adfc57108">instrlist_meta_fault_append</a> (instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a94a1526c7b520c9aefbd775adfc57108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b7bd1e750b8a24ebf401fb6a6d6d5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, void *callee, bool save_fpstate, uint num_args,...)</td></tr>
<tr class="separator:ae7b7bd1e750b8a24ebf401fb6a6d6d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8640a5d47dcf82be4e6a5cf77bd6d967"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a8640a5d47dcf82be4e6a5cf77bd6d967">dr_insert_clean_call_ex</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, void *callee, <a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212">dr_cleancall_save_t</a> save_flags, uint num_args,...)</td></tr>
<tr class="separator:a8640a5d47dcf82be4e6a5cf77bd6d967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a3575059c29dae25ab02c9eb1d0ce9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#af2a3575059c29dae25ab02c9eb1d0ce9">dr_insert_call</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, void *callee, uint num_args,...)</td></tr>
<tr class="separator:af2a3575059c29dae25ab02c9eb1d0ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da72f3ac1f72d1abd12184d66b83f32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a5da72f3ac1f72d1abd12184d66b83f32">dr_insert_call_ex</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, byte *encode_pc, void *callee, uint num_args,...)</td></tr>
<tr class="separator:a5da72f3ac1f72d1abd12184d66b83f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4608ec2db2a288aa5e2a53bb6d19054d"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a4608ec2db2a288aa5e2a53bb6d19054d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466c814771a85f9b53e6681f4dc5c957"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a466c814771a85f9b53e6681f4dc5c957">dr_cleanup_after_call</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, uint sizeof_param_area)</td></tr>
<tr class="separator:a466c814771a85f9b53e6681f4dc5c957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9647e1300201596bc818ca33c95d4cc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a9647e1300201596bc818ca33c95d4cc6">dr_swap_to_clean_stack</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr class="separator:a9647e1300201596bc818ca33c95d4cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2c851eeeee7e669f3e6a7b877977d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a9a2c851eeeee7e669f3e6a7b877977d1">dr_restore_app_stack</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where)</td></tr>
<tr class="separator:a9a2c851eeeee7e669f3e6a7b877977d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4473973127fba8a57f1a4ba409c6938a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a4473973127fba8a57f1a4ba409c6938a">dr_call_on_clean_stack</a> (void *drcontext, void *(*func)(void), void *arg1, void *arg2, void *arg3, void *arg4, void *arg5, void *arg6, void *arg7, void *arg8)</td></tr>
<tr class="separator:a4473973127fba8a57f1a4ba409c6938a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359744bc2776333fbf8f057931ca8eeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a359744bc2776333fbf8f057931ca8eeb">dr_insert_call_instrumentation</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee)</td></tr>
<tr class="separator:a359744bc2776333fbf8f057931ca8eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919e2106df67eaaa5bc6c49d736543b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a919e2106df67eaaa5bc6c49d736543b5">dr_insert_mbr_instrumentation</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee, <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> scratch_slot)</td></tr>
<tr class="separator:a919e2106df67eaaa5bc6c49d736543b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe09a1a1ca19b343279a65141c20f0a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#abe09a1a1ca19b343279a65141c20f0a1">dr_insert_cbr_instrumentation</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee)</td></tr>
<tr class="separator:abe09a1a1ca19b343279a65141c20f0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e0fdfd7cf230aff575191bd49da893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a73e0fdfd7cf230aff575191bd49da893">dr_insert_cbr_instrumentation_ex</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee, <a class="el" href="structopnd__t.html">opnd_t</a> user_data)</td></tr>
<tr class="separator:a73e0fdfd7cf230aff575191bd49da893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3647b439211a8cd70c40478a4113e128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a3647b439211a8cd70c40478a4113e128">dr_insert_ubr_instrumentation</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, void *callee)</td></tr>
<tr class="separator:a3647b439211a8cd70c40478a4113e128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09cc56ad45eb3aa0f10ea5a0cb6aadd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#af09cc56ad45eb3aa0f10ea5a0cb6aadd">dr_clobber_retaddr_after_read</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr, ptr_uint_t value)</td></tr>
<tr class="separator:af09cc56ad45eb3aa0f10ea5a0cb6aadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5921c4f301ea05885f305f9a30b3c0b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a5921c4f301ea05885f305f9a30b3c0b0">dr_mcontext_xmm_fields_valid</a> (void)</td></tr>
<tr class="separator:a5921c4f301ea05885f305f9a30b3c0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ffde2808c16e07f323c34affa72209"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *context)</td></tr>
<tr class="separator:a91ffde2808c16e07f323c34affa72209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56568d24667f5d64264d0bad398727b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a56568d24667f5d64264d0bad398727b3">dr_set_mcontext</a> (void *drcontext, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *context)</td></tr>
<tr class="separator:a56568d24667f5d64264d0bad398727b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f612cf9d0ca2025b23d30b6f5bb0231"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution</a> (<a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *context)</td></tr>
<tr class="separator:a9f612cf9d0ca2025b23d30b6f5bb0231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa101c165975f98f274d0a676136bb32d"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#aa101c165975f98f274d0a676136bb32d">dr_redirect_native_target</a> (void *drcontext)</td></tr>
<tr class="separator:aa101c165975f98f274d0a676136bb32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0a400c44ffafbfa027884b5f895342"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a5d0a400c44ffafbfa027884b5f895342">dr_mcontext_to_context</a> (CONTEXT *dst, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *src)</td></tr>
<tr class="separator:a5d0a400c44ffafbfa027884b5f895342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30dfcf7ed64d1923b9f4e101cc983cb"><td class="memItemLeft" align="right" valign="top">app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#ae30dfcf7ed64d1923b9f4e101cc983cb">decode_memory_reference_size</a> (void *drcontext, app_pc pc, uint *size_in_bytes)</td></tr>
<tr class="separator:ae30dfcf7ed64d1923b9f4e101cc983cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9055369e97457b8656fc8c3c0d6d49d"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#aa9055369e97457b8656fc8c3c0d6d49d">decode_eflags_usage</a> (void *drcontext, byte *pc, uint *usage)</td></tr>
<tr class="separator:aa9055369e97457b8656fc8c3c0d6d49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f62065c2b7e764fe9fb0f46557e2264"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a6f62065c2b7e764fe9fb0f46557e2264">decode</a> (void *drcontext, byte *pc, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a6f62065c2b7e764fe9fb0f46557e2264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad81737da9662a4e6bf697757cb25ddf"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#aad81737da9662a4e6bf697757cb25ddf">decode_from_copy</a> (void *drcontext, byte *copy_pc, byte *orig_pc, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:aad81737da9662a4e6bf697757cb25ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1321b3d18f45de750edfe2ff6ba151d2"><td class="memItemLeft" align="right" valign="top">instrlist_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a1321b3d18f45de750edfe2ff6ba151d2">decode_as_bb</a> (void *drcontext, byte *start_pc)</td></tr>
<tr class="separator:a1321b3d18f45de750edfe2ff6ba151d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe7afa4c8654b0ee88ccd88d1f2d698"><td class="memItemLeft" align="right" valign="top">instrlist_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#adbe7afa4c8654b0ee88ccd88d1f2d698">decode_trace</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:adbe7afa4c8654b0ee88ccd88d1f2d698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4946f4ab326ef4695fce55eb434c2cde"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a4946f4ab326ef4695fce55eb434c2cde">decode_first_opcode_byte</a> (int opcode)</td></tr>
<tr class="separator:a4946f4ab326ef4695fce55eb434c2cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3952e7614f4bf8e62f360f08683ad8a0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a3952e7614f4bf8e62f360f08683ad8a0">decode_opcode_name</a> (int opcode)</td></tr>
<tr class="separator:a3952e7614f4bf8e62f360f08683ad8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8b8756bdc063a88d206f17cc5e3e2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a2a8b8756bdc063a88d206f17cc5e3e2c">decode_sizeof</a> (void *drcontext, byte *pc, int *num_prefixes _IF_X64(uint *rip_rel_pos))</td></tr>
<tr class="separator:a2a8b8756bdc063a88d206f17cc5e3e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813105fc7196a85e73580d1adfb8d336"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a813105fc7196a85e73580d1adfb8d336">decode_next_pc</a> (void *drcontext, byte *pc)</td></tr>
<tr class="separator:a813105fc7196a85e73580d1adfb8d336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3082c5db55039c72ae30e3276f622aae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a3082c5db55039c72ae30e3276f622aae">disassemble_set_syntax</a> (<a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3">dr_disasm_flags_t</a> flags)</td></tr>
<tr class="separator:a3082c5db55039c72ae30e3276f622aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526fc9f23e78b5f1321891dc8f81b1b7"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a526fc9f23e78b5f1321891dc8f81b1b7">disassemble</a> (void *drcontext, byte *pc, file_t outfile)</td></tr>
<tr class="separator:a526fc9f23e78b5f1321891dc8f81b1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c491ac5c40069f120b0ef512ccc7166"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a2c491ac5c40069f120b0ef512ccc7166">disassemble_with_info</a> (void *drcontext, byte *pc, file_t outfile, bool show_pc, bool show_bytes)</td></tr>
<tr class="separator:a2c491ac5c40069f120b0ef512ccc7166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6a5d44647c481f50ee5208281617ba"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a2e6a5d44647c481f50ee5208281617ba">disassemble_from_copy</a> (void *drcontext, byte *copy_pc, byte *orig_pc, file_t outfile, bool show_pc, bool show_bytes)</td></tr>
<tr class="separator:a2e6a5d44647c481f50ee5208281617ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3978e8cb7ba406cf7c9fed00b9c4a9bf"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__utils_8h.html#a3978e8cb7ba406cf7c9fed00b9c4a9bf">disassemble_to_buffer</a> (void *drcontext, byte *pc, byte *orig_pc, bool show_pc, bool show_bytes, char *buf, size_t bufsz, int *printed OUT)</td></tr>
<tr class="separator:a3978e8cb7ba406cf7c9fed00b9c4a9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Code transformation utilities. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a85e6559244f2fc5b84c7a07f04168bad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPILL_SLOT_REDIRECT_NATIVE_TGT&#160;&#160;&#160;SPILL_SLOT_1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags to request non-default preservation of state in a clean call </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="af1b1bc23c42ffb7452568176b09b1212"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212">dr_cleancall_save_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags to request non-default preservation of state in a clean call as well as other call options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="af1b1bc23c42ffb7452568176b09b1212ac04fbaff072a9ec162172cdd8305080d"></a>DR_CLEANCALL_SAVE_FLOAT</em>&#160;</td><td class="fielddoc">
<p>Save floating-point state. The last floating-point instruction address in the saved state is left in an untranslated state (i.e., it may point into the code cache). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af1b1bc23c42ffb7452568176b09b1212a2b03fe8506703bdcc4c24c49f6f16915"></a>DR_CLEANCALL_NOSAVE_FLAGS</em>&#160;</td><td class="fielddoc">
<p>Skip saving the flags and skip clearing the flags (including DF) for client execution. Note that this can cause problems if <a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution()</a> is called from a clean call, as an uninitialized flags value can cause subtle errors. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af1b1bc23c42ffb7452568176b09b1212abde57f92afb00d994bc1ea596ba31306"></a>DR_CLEANCALL_NOSAVE_XMM</em>&#160;</td><td class="fielddoc">
<p>Skip saving any XMM or YMM registers. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af1b1bc23c42ffb7452568176b09b1212a04d3bcbf34926384e13d48d45aa42d2a"></a>DR_CLEANCALL_NOSAVE_XMM_NONPARAM</em>&#160;</td><td class="fielddoc">
<p>Skip saving any XMM or YMM registers that are never used as parameters. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af1b1bc23c42ffb7452568176b09b1212a658cc567c0e4c91c0a065a17cb7ba5ed"></a>DR_CLEANCALL_NOSAVE_XMM_NONRET</em>&#160;</td><td class="fielddoc">
<p>Skip saving any XMM or YMM registers that are never used as return values. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af1b1bc23c42ffb7452568176b09b1212a9fe53fc77afb460ba31666995df5b6c9"></a>DR_CLEANCALL_INDIRECT</em>&#160;</td><td class="fielddoc">
<p>Requests that an indirect call be used to ensure reachability. Only honored for 64-bit mode, where r11 will be used for the indirection. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a4c1e2fa2049719870ad0c1007b00d4e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3">dr_disasm_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags controlling disassembly style </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a4c1e2fa2049719870ad0c1007b00d4e3af82d1bee9aa93ac6df451bd80a4b1278"></a>DR_DISASM_DR</em>&#160;</td><td class="fielddoc">
<p>The default: displays all operands, including implicit operands. Lists source operands first, then "-&gt;", and then destination operands. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4c1e2fa2049719870ad0c1007b00d4e3a406704bf086c0d17c5bfade619533835"></a>DR_DISASM_INTEL</em>&#160;</td><td class="fielddoc">
<p>Requests Intel syntax for disassembly. This sets the same option that is controlled by the runtime option <code>-syntax_intel</code>. Implicit operands are not displayed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4c1e2fa2049719870ad0c1007b00d4e3a83d3ece1134b8dabc7f0fd2f84185f11"></a>DR_DISASM_ATT</em>&#160;</td><td class="fielddoc">
<p>Requests AT&amp;T syntax for disassembly. This sets the same option that is controlled by the runtime option <code>-syntax_att</code>. Implicit operands are not displayed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4c1e2fa2049719870ad0c1007b00d4e3aa9e5caa6773c8f8a4ff13b77231dbdaf"></a>DR_DISASM_STRICT_INVALID</em>&#160;</td><td class="fielddoc">
<p>Certain reserved or unspecified opcodes are in a gray area where they could be decoded with their length and operands understood, but they are not fully defined and in fact they may raise an illegal instruction fault when executed. By default, DR does not treat them as invalid. If this option is set, DR tightens up its decoding and does treat them as invalid. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4c1e2fa2049719870ad0c1007b00d4e3a4371407d86fde325673f7d3967037708"></a>DR_DISASM_NO_OPND_SIZE</em>&#160;</td><td class="fielddoc">
<p>This flag only applies to the default DR style (i.e., it does not apply when DR_DISASM_INTEL or DR_DISASM_ATT is selected). That style by default displays the size of memory or sub-register operands via a suffix "[Nbytes]". Setting this flag removes that suffix. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a89a6b714ff24d91d78589877047a29b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enum of spill slots to use with <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a>, <a class="el" href="dr__ir__utils_8h.html#a453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg()</a>, <a class="el" href="dr__ir__utils_8h.html#a44636ca6809a9fb22cf817701de9ee09">dr_save_arith_flags()</a>, <a class="el" href="dr__ir__utils_8h.html#a563b0de37a51cb2e84337deef30a57cf">dr_restore_arith_flags()</a> and <a class="el" href="dr__ir__utils_8h.html#a919e2106df67eaaa5bc6c49d736543b5">dr_insert_mbr_instrumentation()</a>. Values stored in spill slots remain valid only until the next non-meta (i.e. application) instruction. Spill slots can be accessed/modifed during clean calls and restore_state_events (see <a class="el" href="dr__events_8h.html#ae7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a>) with <a class="el" href="dr__ir__utils_8h.html#abb63ecfaa5256688bab9a2921fc19227">dr_read_saved_reg()</a> and <a class="el" href="dr__ir__utils_8h.html#abf8d50d718883a1caf6a2de0fb3dbce3">dr_write_saved_reg()</a>.</p>
<p>Spill slots &lt;= <a class="el" href="dr__ir__utils_8h.html#a762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot()</a> can be directly accessed from client inserted instructions with <a class="el" href="dr__ir__utils_8h.html#a5eab608c134db044f2d9453a8407d470">dr_reg_spill_slot_opnd()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Some spill slots may be faster to access than others. Currently spill slots 1-3 are significantly faster to access than the others when running without -thread_private. When running with -thread_private all spill slots are expected to have similar performance. This is subject to change in future releases, but clients may assume that smaller numbered spill slots are faster or the same cost to access as larger numbered spill slots.</dd>
<dd>
The number of spill slots may change in future releases. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9ae4cd78beccb2525acc61f2536ba1ea71"></a>SPILL_SLOT_2</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a446ae7a7df24d2c3abae567a17289566"></a>SPILL_SLOT_3</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9ab1b97fb0822126941b211160965034e4"></a>SPILL_SLOT_4</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a57734b157aa48d5db278cb1aa372cd56"></a>SPILL_SLOT_5</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9ac4c22f3fdbacb7b37b55484b5577f1e0"></a>SPILL_SLOT_6</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9abbff886ccbde7dc9ce9bd4e379eb7ac3"></a>SPILL_SLOT_7</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a6bbd68ecb5a36a22f247c5806fa5fec9"></a>SPILL_SLOT_8</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9aa1bffc7b66f58d71b52284c0f49d5a53"></a>SPILL_SLOT_9</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a44005b876b8364b0433f880f5b9b1a68"></a>SPILL_SLOT_10</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a78ba623c508dc9db382bd16205e862c5"></a>SPILL_SLOT_11</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
<dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a3bd3a0c1a09dd08a8cf3cdc99902767a"></a>SPILL_SLOT_12</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
<dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a2a009fac1a98d5546313cb17b0a026a7"></a>SPILL_SLOT_13</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
<dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9ace6bda60e6d81dc4914384f28d2e159e"></a>SPILL_SLOT_14</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
<dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a529c3a41f0f3324929310b94915de96e"></a>SPILL_SLOT_15</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
<dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a3d4436b445175a7088cd958a7e81f9b8"></a>SPILL_SLOT_16</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
<dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a8483a4f53a6c380d0356a0596745ce09"></a>SPILL_SLOT_17</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
<dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a89a6b714ff24d91d78589877047a29b9a794503b196c55da22002fc15549916fa"></a>SPILL_SLOT_MAX</em>&#160;</td><td class="fielddoc">
<p>spill slot for register save/restore routines </p>
<dl class="section note"><dt>Note</dt><dd>x64 only </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6f62065c2b7e764fe9fb0f46557e2264"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* decode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes the instruction at address <code>pc</code> into <code>instr</code>, filling in the instruction's opcode, eflags usage, prefixes, and operands. The instruction's raw bits are set to valid and pointed at <code>pc</code> (xref <a class="el" href="dr__ir__instr_8h.html#a964928ee44090aba9aef343c5d34df5c">instr_get_raw_bits()</a>). Assumes that <code>instr</code> is already initialized, but uses the x86/x64 mode for the thread <code>dcontext</code> rather than that set in instr. If caller is re-using same <a class="el" href="structinstr__t.html">instr_t</a> struct over multiple decodings, caller should call <a class="el" href="dr__ir__instr_8h.html#accd2bdee07d2e6ca0be3b252bc7b913f">instr_reset()</a> or <a class="el" href="dr__ir__instr_8h.html#ab9b44a1db49dc5cd8da8b6b27fa47d50">instr_reuse()</a>. Returns the address of the next byte after the decoded instruction. Returns NULL on decoding an invalid instr and sets opcode to OP_INVALID. </p>

</div>
</div>
<a class="anchor" id="a1321b3d18f45de750edfe2ff6ba151d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">instrlist_t* decode_as_bb </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>start_pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Client routine to decode instructions at an arbitrary app address, following all the rules that DynamoRIO follows internally for terminating basic blocks. Note that DynamoRIO does not validate that <code>start_pc</code> is actually the first instruction of a basic block. </p>
<dl class="section note"><dt>Note</dt><dd>Caller is reponsible for freeing the list and its instrs! </dd></dl>

</div>
</div>
<a class="anchor" id="aa9055369e97457b8656fc8c3c0d6d49d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* decode_eflags_usage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>usage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes only enough of the instruction at address <code>pc</code> to determine its eflags usage, which is returned in <code>usage</code> as EFLAGS_ constants or'ed together. Returns the address of the next byte after the decoded instruction. Returns NULL on decoding an invalid instruction. </p>

</div>
</div>
<a class="anchor" id="a4946f4ab326ef4695fce55eb434c2cde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte decode_first_opcode_byte </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an OP_ constant, returns the first byte of its opcode when encoded as an IA-32 instruction. </p>

</div>
</div>
<a class="anchor" id="aad81737da9662a4e6bf697757cb25ddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* decode_from_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>orig_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes the instruction at address <code>copy_pc</code> into <code>instr</code> as though it were located at address <code>orig_pc</code>. Any pc-relative operands have their values calculated as though the instruction were actually at <code>orig_pc</code>, though that address is never de-referenced. The instruction's raw bits are not valid, but its application address field (see <a class="el" href="dr__ir__instr_8h.html#a57dbc129ab88dfdcf49f1105eba394a7">instr_get_app_pc()</a>) is set to <code>orig_pc</code>. The instruction's opcode, eflags usage, prefixes, and operands are all filled in. Assumes that <code>instr</code> is already initialized, but uses the x86/x64 mode for the thread <code>dcontext</code> rather than that set in instr. If caller is re-using same <a class="el" href="structinstr__t.html">instr_t</a> struct over multiple decodings, caller should call <a class="el" href="dr__ir__instr_8h.html#accd2bdee07d2e6ca0be3b252bc7b913f">instr_reset()</a> or <a class="el" href="dr__ir__instr_8h.html#ab9b44a1db49dc5cd8da8b6b27fa47d50">instr_reuse()</a>. Returns the address of the next byte after the decoded instruction copy at <code>copy_pc</code>. Returns NULL on decoding an invalid instr and sets opcode to OP_INVALID. </p>

</div>
</div>
<a class="anchor" id="ae30dfcf7ed64d1923b9f4e101cc983cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc decode_memory_reference_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the size, in bytes, of the memory read or write of the instr at <code>pc</code>. If the instruction is a repeating string instruction, considers only one iteration. Returns the pc of the following instruction. If the instruction at <code>pc</code> does not reference memory, or is invalid, returns NULL. </p>

</div>
</div>
<a class="anchor" id="a813105fc7196a85e73580d1adfb8d336"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* decode_next_pc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes only enough of the instruction at address <code>pc</code> to determine its size. Returns the address of the byte following the instruction. Returns NULL on decoding an invalid instruction. </p>

</div>
</div>
<a class="anchor" id="a3952e7614f4bf8e62f360f08683ad8a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* decode_opcode_name </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an OP_ constant, returns the string name of its opcode. </p>

</div>
</div>
<a class="anchor" id="a2a8b8756bdc063a88d206f17cc5e3e2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decode_sizeof </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *num_prefixes &#160;</td>
          <td class="paramname"><em>_IF_X64</em>uint *rip_rel_pos&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes only enough of the instruction at address <code>pc</code> to determine its size. Returns that size. If <code>num_prefixes</code> is non-NULL, returns the number of prefix bytes. If <code>rip_rel_pos</code> is non-NULL, returns the offset into the instruction of a rip-relative addressing displacement (for data only: ignores control-transfer relative addressing), or 0 if none. May return 0 size for certain invalid instructions. </p>

</div>
</div>
<a class="anchor" id="adbe7afa4c8654b0ee88ccd88d1f2d698"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">instrlist_t* decode_trace </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes the trace with tag <code>tag</code>, and returns an instrlist_t of the instructions comprising that fragment. If <code>tag</code> is not a valid tag for an existing trace, the routine returns NULL. Clients can use <a class="el" href="dr__tools_8h.html#a1d4c9a29f1c962457c123322aa3e1931">dr_trace_exists_at()</a> to determine whether the trace exists. </p>
<dl class="section note"><dt>Note</dt><dd>Unlike the instruction list presented by the trace event, the list here does not include any existing client modifications. If client-modified instructions are needed, it is the responsibility of the client to record or recreate that list itself. </dd>
<dd>
This routine does not support decoding thread-private traces created by other than the calling thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a526fc9f23e78b5f1321891dc8f81b1b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* disassemble </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>outfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes and then prints the instruction at address <code>pc</code> to file <code>outfile</code>. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. Returns the address of the subsequent instruction, or NULL if the instruction at <code>pc</code> is invalid. </p>

</div>
</div>
<a class="anchor" id="a2e6a5d44647c481f50ee5208281617ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* disassemble_from_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>orig_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes the instruction at address <code>copy_pc</code> as though it were located at address <code>orig_pc</code>, and then prints the instruction to file <code>outfile</code>. Prior to the instruction the address <code>orig_pc</code> is printed if <code>show_pc</code> and the raw bytes are printed if <code>show_bytes</code>. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. Returns the address of the subsequent instruction after the copy at <code>copy_pc</code>, or NULL if the instruction at <code>copy_pc</code> is invalid. </p>

</div>
</div>
<a class="anchor" id="a3082c5db55039c72ae30e3276f622aae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void disassemble_set_syntax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a4c1e2fa2049719870ad0c1007b00d4e3">dr_disasm_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the disassembly style and decoding options. </p>

</div>
</div>
<a class="anchor" id="a3978e8cb7ba406cf7c9fed00b9c4a9bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* disassemble_to_buffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>orig_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *printed&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes the instruction at address <code>pc</code> as though it were located at address <code>orig_pc</code>, and then prints the instruction to the buffer <code>buf</code>. Always null-terminates, and will not print more than <code>bufsz</code> characters, which includes the final null character. Indicates the number of characters printed, not including the final null, in <code>printed</code>, if <code>printed</code> is non-NULL.</p>
<p>Prior to the instruction the address <code>orig_pc</code> is printed if <code>show_pc</code> and the raw bytes are printed if <code>show_bytes</code>. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. Returns the address of the subsequent instruction after the copy at <code>copy_pc</code>, or NULL if the instruction at <code>copy_pc</code> is invalid. </p>

</div>
</div>
<a class="anchor" id="a2c491ac5c40069f120b0ef512ccc7166"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* disassemble_with_info </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>outfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes and then prints the instruction at address <code>pc</code> to file <code>outfile</code>. Prior to the instruction the address is printed if <code>show_pc</code> and the raw bytes are printed if <code>show_bytes</code>. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. Returns the address of the subsequent instruction, or NULL if the instruction at <code>pc</code> is invalid. </p>

</div>
</div>
<a class="anchor" id="a4473973127fba8a57f1a4ba409c6938a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_call_on_clean_stack </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls the specified function <code>func</code> after switching to the DR stack for the thread corresponding to <code>drcontext</code>. Passes in 8 arguments. Uses the C calling convention, so <code>func</code> will work just fine even if if takes fewer than 8 args. Swaps the stack back upon return and returns the value returned by <code>func</code>. </p>

</div>
</div>
<a class="anchor" id="a466c814771a85f9b53e6681f4dc5c957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_cleanup_after_call </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>sizeof_param_area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore state after a call. </p>

</div>
</div>
<a class="anchor" id="af09cc56ad45eb3aa0f10ea5a0cb6aadd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_clobber_retaddr_after_read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_uint_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes DynamoRIO to insert code that stores <code>value</code> into the return address slot on the stack immediately after the original value is read by the return instruction <code>instr</code>. <code>instr</code> must be a return instruction or this routine will fail.</p>
<dl class="section note"><dt>Note</dt><dd>This is meant to make it easier to obtain efficient callstacks by eliminating stale return addresses from prior stack frames. However, it is possible that writing to the application stack could result in incorrect application behavior, so use this at your own risk.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a91ffde2808c16e07f323c34affa72209"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_get_mcontext </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the fields of the current application machine context selected by the <code>flags</code> field of <code>context</code> into <code>context</code>.</p>
<p>This routine may only be called from:</p>
<ul>
<li>A clean call invoked by <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a></li>
<li>A pre- or post-syscall event (<a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>, <a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>)</li>
<li>Basic block or trace creation events (<a class="el" href="dr__events_8h.html#a043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a>, <a class="el" href="dr__events_8h.html#a88a19a6822654caf18c017e145f48a57">dr_register_trace_event()</a>), but for basic block creation only when the basic block callback parameters <code>for_trace</code> and <code>translating</code> are false, and for trace creation only when <code>translating</code> is false.</li>
<li>A nudge callback (<a class="el" href="dr__events_8h.html#a9037603d0bd5bfca4198011adb8d10eb">dr_register_nudge_event()</a>) on Linux. (On Windows nudges happen in separate dedicated threads.)</li>
<li>A thread or process exit event (<a class="el" href="dr__events_8h.html#a0b0c102bb9a99d67c3e62ea8b3790ff1">dr_register_thread_exit_event()</a>, <a class="el" href="dr__events_8h.html#a985537df683007e1392e8a3b095ef363">dr_register_exit_event()</a>)</li>
<li>A thread init event (<a class="el" href="dr__events_8h.html#a878920c40c76e2c18043f9db772a24c0">dr_register_thread_init_event()</a>) for all but the initial thread.</li>
</ul>
<p>Even when DR_MC_CONTROL is specified, does NOT copy the pc field, except for system call events, when it will point at the post-syscall address.</p>
<p>Returns false if called from the init event or the initial thread's init event; returns true otherwise (cannot distinguish whether the caller is in a clean call so it is up to the caller to ensure it is used properly).</p>
<p>The size field of <code>context</code> must be set to the size of the structure as known at compile time. If the size field is invalid, this routine will return false.</p>
<p>The flags field of <code>context</code> must be set to the desired amount of information using the dr_mcontext_flags_t values. Asking for multimedia registers incurs a higher performance cost. An invalid flags value will return false.</p>
<dl class="section note"><dt>Note</dt><dd>NUM_XMM_SLOTS in the dr_mcontext_t.xmm array are filled in, but only if <a class="el" href="dr__ir__utils_8h.html#a5921c4f301ea05885f305f9a30b3c0b0">dr_mcontext_xmm_fields_valid()</a> returns true and DR_MC_MULTIMEDIA is set in the flags field.</dd>
<dd>
The context is the context saved at the <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a> points. It does not correct for any registers saved with <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a>. To access registers saved with <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a> from a clean call use <a class="el" href="dr__ir__utils_8h.html#abb63ecfaa5256688bab9a2921fc19227">dr_read_saved_reg()</a>.</dd>
<dd>
System data structures are swapped to private versions prior to invoking clean calls or client events. Use <a class="el" href="dr__tools_8h.html#aa2944aa54d591a236f5334a35bfb41bf">dr_switch_to_app_state()</a> to examine the application version of system state. </dd></dl>

</div>
</div>
<a class="anchor" id="af2a3575059c29dae25ab02c9eb1d0ce9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_call </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to set up the passed-in parameters, make a call to <code>callee</code>, and clean up the parameters.</p>
<p>The callee must use the standard C calling convention that matches the underlying 32-bit or 64-bit binary interface convention ("cdecl"). Other calling conventions, such as "fastcall" and "stdcall", are not supported.</p>
<p>This routine uses the existing stack. In 64-bit mode, this routine assumes that the stack pointer is currently 16-byte aligned.</p>
<p>The application state is NOT saved or restored (use <a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a> and <a class="el" href="dr__ir__utils_8h.html#a466c814771a85f9b53e6681f4dc5c957">dr_cleanup_after_call()</a>, or replace this routine with <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a>). The parameter set-up may write to registers if the calling convention so dictates. The registers are NOT saved beforehand (to do so, use <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a>).</p>
<p>It is up to the caller of this routine to preserve any caller-saved registers that the callee might modify.</p>
<p>DR does not support translating a fault in an argument. For fault transparency, the client must perform the translation (see <a class="el" href="dr__events_8h.html#ae7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a>), or use <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a>.</p>
<p>For 64-bit, for purposes of reachability, this call is assumed to be destined for encoding into DR's code cache-reachable memory region. This includes the code cache as well as memory allocated with <a class="el" href="dr__tools_8h.html#a4274226adda06339e247e4a311abdd9b">dr_thread_alloc()</a>, <a class="el" href="dr__tools_8h.html#a60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc()</a>, <a class="el" href="dr__tools_8h.html#ac32b5be072876c25a832d510efeba6e4">dr_nonheap_alloc()</a>, or <a class="el" href="dr__tools_8h.html#a3cfff0780cf83588e3d71da552490eb7">dr_custom_alloc()</a> with <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ab33a2e990410bf314bdebe6a25aa06e1">DR_ALLOC_CACHE_REACHABLE</a>. The call used here will be direct if it is reachable from those locations; if it is not reachable, an indirect call through r11 will be used (with r11's contents being clobbered). Use <a class="el" href="dr__ir__utils_8h.html#a5da72f3ac1f72d1abd12184d66b83f32">dr_insert_call_ex()</a> when encoding to a location other than DR's regular code region.</p>
<dl class="section note"><dt>Note</dt><dd>This routine only supports passing arguments that are integers or pointers of a size equal to the register size: i.e., no floating-point, multimedia, or aggregate data types. The routine also supports immediate integers that are smaller than the register size, and for 64-bit mode registers or memory references that are OPSZ_4.</dd>
<dd>
For 64-bit mode, passing arguments that use calling convention registers (for Windows, RCX, RDX, R8, R9; for Linux, RDI, RSI, RDX, RCX, R8 and R9) are supported but may incur additional stack usage.</dd>
<dd>
For 64-bit mode, if a 32-bit immediate integer is specified as an argument and it has its top bit set, we assume it is intended to be sign-extended to 64-bits; otherwise we zero-extend it.</dd>
<dd>
For 64-bit mode, variable-sized argument operands may not work properly.</dd>
<dd>
Arguments that reference DR_REG_XSP are not supported in 64-bit mode. </dd></dl>

</div>
</div>
<a class="anchor" id="a5da72f3ac1f72d1abd12184d66b83f32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_insert_call_ex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>encode_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__ir__utils_8h.html#af2a3575059c29dae25ab02c9eb1d0ce9">dr_insert_call()</a> except it takes in <code>encode_pc</code> indicating roughly where the call sequence will be encoded. If <code>callee</code> is not reachable from <code>encode_pc</code> plus or minus one page, an indirect call will be used instead of the direct call used by <a class="el" href="dr__ir__utils_8h.html#af2a3575059c29dae25ab02c9eb1d0ce9">dr_insert_call()</a>. The indirect call overwrites the r11 register.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the inserted call is direct and false if indirect. </dd></dl>

</div>
</div>
<a class="anchor" id="a359744bc2776333fbf8f057931ca8eeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_call_instrumentation </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> is a near call. Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing two arguments:</p>
<ol type="1">
<li>address of call instruction (caller)</li>
<li>target address of call (callee) </li>
</ol>

</div>
</div>
<a class="anchor" id="abe09a1a1ca19b343279a65141c20f0a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_cbr_instrumentation </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> is a conditional branch Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing three arguments:</p>
<ol type="1">
<li>address of branch instruction</li>
<li>target address of branch</li>
<li>0 if the branch is not taken, 1 if it is taken </li>
</ol>

</div>
</div>
<a class="anchor" id="a73e0fdfd7cf230aff575191bd49da893"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_cbr_instrumentation_ex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> is a conditional branch Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing four arguments:</p>
<ol type="1">
<li>address of branch instruction</li>
<li>target address of branch</li>
<li>fall-through address of branch</li>
<li>0 if the branch is not taken, 1 if it is taken</li>
<li>user defined operand (e.g., TLS slot, immed value, register, etc.) <dl class="section note"><dt>Note</dt><dd>The user defined operand cannot use register ebx! </dd></dl>
</li>
</ol>

</div>
</div>
<a class="anchor" id="ae7b7bd1e750b8a24ebf401fb6a6d6d5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_clean_call </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_fpstate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save state for a call, switch to this thread's DR stack, set up the passed-in parameters, make a call to <code>callee</code>, clean up the parameters, and then restore the saved state.</p>
<p>The callee must use the standard C calling convention that matches the underlying 32-bit or 64-bit binary interface convention ("cdecl"). Other calling conventions, such as "fastcall" and "stdcall", are not supported.</p>
<p>Stores the application state information on the DR stack, where it can be accessed from <code>callee</code> using <a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a> and modified using <a class="el" href="dr__ir__utils_8h.html#a56568d24667f5d64264d0bad398727b3">dr_set_mcontext()</a>.</p>
<p>If <code>save_fpstate</code> is true, preserves the fp/mmx/sse state on the DR stack. Note that it is relatively expensive to save this state (on the order of 200 cycles) and that it typically takes 512 bytes to store it (see <a class="el" href="dr__proc_8h.html#a468a29572175ba1d3ca7dbeb1fdbb825">proc_fpstate_save_size()</a>). The last floating-point instruction address in the saved state is left in an untranslated state (i.e., it may point into the code cache).</p>
<p>DR does support translating a fault in an argument (e.g., an argument that references application memory); such a fault will be treated as an application exception.</p>
<p>The clean call sequence will be optimized based on the runtime option <a class="el" href="using.html#op_cleancall">-opt_cleancall</a>.</p>
<p>For 64-bit, for purposes of reachability, this call is assumed to be destined for encoding into DR's code cache-reachable memory region. This includes the code cache as well as memory allocated with <a class="el" href="dr__tools_8h.html#a4274226adda06339e247e4a311abdd9b">dr_thread_alloc()</a>, <a class="el" href="dr__tools_8h.html#a60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc()</a>, <a class="el" href="dr__tools_8h.html#ac32b5be072876c25a832d510efeba6e4">dr_nonheap_alloc()</a>, or <a class="el" href="dr__tools_8h.html#a3cfff0780cf83588e3d71da552490eb7">dr_custom_alloc()</a> with <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ab33a2e990410bf314bdebe6a25aa06e1">DR_ALLOC_CACHE_REACHABLE</a>. The call used here will be direct if it is reachable from those locations; if it is not reachable, an indirect call through r11 will be used (with r11's contents being clobbered). Use <a class="el" href="dr__ir__utils_8h.html#a8640a5d47dcf82be4e6a5cf77bd6d967">dr_insert_clean_call_ex()</a> with <a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212a9fe53fc77afb460ba31666995df5b6c9">DR_CLEANCALL_INDIRECT</a> to ensure reachability when encoding to a location other than DR's regular code region. See also <a class="el" href="dr__ir__utils_8h.html#a5da72f3ac1f72d1abd12184d66b83f32">dr_insert_call_ex()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The stack used to save state and call <code>callee</code> is limited to 20KB by default; this can be changed with the -stack_size DR runtime parameter. This stack cannot be used to store state that persists beyond <code>callee's</code> return point.</dd>
<dd>
This routine only supports passing arguments that are integers or pointers of a size equal to the register size: i.e., no floating-point, multimedia, or aggregate data types. The routine also supports immediate integers that are smaller than the register size, and for 64-bit mode registers or memory references that are OPSZ_4.</dd>
<dd>
For 64-bit mode, passing arguments that use calling convention registers (for Windows, RCX, RDX, R8, R9; for Linux, RDI, RSI, RDX, RCX, R8 and R9) are supported but may incur additional stack usage.</dd>
<dd>
For 64-bit mode, if a 32-bit immediate integer is specified as an argument and it has its top bit set, we assume it is intended to be sign-extended to 64-bits; otherwise we zero-extend it.</dd>
<dd>
For 64-bit mode, variable-sized argument operands may not work properly.</dd>
<dd>
Arguments that reference sub-register portions of DR_REG_XSP are not supported (full DR_REG_XSP is supported). </dd></dl>

</div>
</div>
<a class="anchor" id="a8640a5d47dcf82be4e6a5cf77bd6d967"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_clean_call_ex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#af1b1bc23c42ffb7452568176b09b1212">dr_cleancall_save_t</a>&#160;</td>
          <td class="paramname"><em>save_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> except it takes in <code>save_flags</code> which allows requests to not save certain state. This is intended for use at application call entry points or other contexts where a client is comfortable making assumptions. Keep in mind that any register that is not saved will not be present in a context obtained from <a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a>. </p>

</div>
</div>
<a class="anchor" id="a919e2106df67eaaa5bc6c49d736543b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_mbr_instrumentation </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>scratch_slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> is an indirect branch. Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing two arguments:</p>
<ol type="1">
<li>address of branch instruction</li>
<li>target address of branch <dl class="section note"><dt>Note</dt><dd>Only the address portion of a far indirect branch is considered. </dd>
<dd>
<code>scratch_slot</code> must be &lt;= <a class="el" href="dr__ir__utils_8h.html#a762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot()</a>. <code>scratch_slot</code> is used internally to this routine and will be clobbered. </dd></dl>
</li>
</ol>

</div>
</div>
<a class="anchor" id="a3831354cc7402d68719d8055fb3e9931"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_read_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to read into the general-purpose full-size register <code>reg</code> from the user-controlled drcontext field for this thread. Reads from the same field as <a class="el" href="dr__tools_8h.html#a787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field()</a>. </p>

</div>
</div>
<a class="anchor" id="a3647b439211a8cd70c40478a4113e128"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_ubr_instrumentation </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> is a direct, near, unconditional branch. Inserts into <code>ilist</code> prior to <code>instr</code> instruction(s) to call callee passing two arguments:</p>
<ol type="1">
<li>address of branch instruction</li>
<li>target address of branch</li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd>Basic block eliding is controlled by -max_elide_jmp. If that option is set to non-zero, ubrs may never be seen. </dd></dl>

</div>
</div>
<a class="anchor" id="a982089284bd51339f448ec4b3928d3b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_write_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to write the general-purpose full-size register <code>reg</code> to the user-controlled drcontext field for this thread. Writes to the same field as <a class="el" href="dr__tools_8h.html#a05b499c8a3115e9ceb4c45dbee660738">dr_set_tls_field()</a>. </p>

</div>
</div>
<a class="anchor" id="a762389f8ae9d809fd7b8f1418cdbd5ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> dr_max_opnd_accessible_spill_slot </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the largest dr_spill_slot_t that can be accessed with an <a class="el" href="structopnd__t.html">opnd_t</a> from <a class="el" href="dr__ir__utils_8h.html#a5eab608c134db044f2d9453a8407d470">dr_reg_spill_slot_opnd()</a>. </p>

</div>
</div>
<a class="anchor" id="a5d0a400c44ffafbfa027884b5f895342"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_mcontext_to_context </td>
          <td>(</td>
          <td class="paramtype">CONTEXT *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the machine state in <code>src</code> into <code>dst</code>. Sets the <code>ContextFlags</code> field of <code>dst</code> to reflect the <code>flags</code> field of <code>src</code>.</p>
<p>It is up to the caller to ensure that <code>dst</code> is allocated and initialized properly in order to contain multimedia processor state, if DR_MC_MULTIMEDIA is set in the <code>flags</code> field of <code>src</code>.</p>
<p>The current segment register values are filled in under the assumption that this context is for the calling thread.</p>
<dl class="section note"><dt>Note</dt><dd>floating-point values are not filled in for <code>dst</code>. </dd>
<dd>
Windows only.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if unsuccessful; if successful, does not return. </dd></dl>

</div>
</div>
<a class="anchor" id="a5921c4f301ea05885f305f9a30b3c0b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_mcontext_xmm_fields_valid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the xmm0 through xmm5 for Windows, or xmm0 through xmm15 for 64-bit Linux, or xmm0 through xmm7 for 32-bit Linux, fields in dr_mcontext_t are valid for this process (i.e., whether this process is 64-bit or WOW64, and the processor supports SSE). </p>
<dl class="section note"><dt>Note</dt><dd>If DR_MC_MULTIMEDIA is not specified when calling <a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a>, the xmm fields will not be filled in regardless of the return value of this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="a4608ec2db2a288aa5e2a53bb6d19054d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint dr_prepare_for_call </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save state for a call. Stores the application state information on the DR stack. Returns the size of the data stored on the DR stack (in case the caller needs to align the stack pointer).</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does NOT save the fp/mmx/sse state: to do that the instrumentation routine should call <a class="el" href="dr__proc_8h.html#a4a11c9d5d127ce126562ad35b4d165dd">proc_save_fpstate()</a> to save and then <a class="el" href="dr__proc_8h.html#a23edceee5d1ae7c7d51a212432e6d644">proc_restore_fpstate()</a> to restore (or use <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The preparation modifies the DR_REG_XSP and DR_REG_XAX registers (after saving them). Use <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> instead if an argument to the subsequent call that references DR_REG_XAX is desired.</dd>
<dd>
The stack used to save the state is limited to 20KB by default; this can be changed with the -stack_size DR runtime parameter. This stack cannot be used to store state that persists beyond a single clean call, code cache execution, or probe callback function execution. </dd></dl>

</div>
</div>
<a class="anchor" id="abb63ecfaa5256688bab9a2921fc19227"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reg_t dr_read_saved_reg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Can be used from a clean call or a restore_state_event (see <a class="el" href="dr__events_8h.html#ae7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a>) to see the value saved in spill slot <code>slot</code> by <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a>. </p>

</div>
</div>
<a class="anchor" id="a9f612cf9d0ca2025b23d30b6f5bb0231"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_redirect_execution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately resumes application execution from a clean call out of the cache (see <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a>) or an exception event with the state specified in <code>mcontext</code> (including pc, and including the xmm fields that are valid according to <a class="el" href="dr__ir__utils_8h.html#a5921c4f301ea05885f305f9a30b3c0b0">dr_mcontext_xmm_fields_valid()</a>). The flags field of <code>context</code> must contain DR_MC_ALL; using a partial set of fields is not suported.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a> can be used to get the register state (except pc) saved in <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a></dd>
<dd>
If floating point state was saved by <a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a> or <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> it is not restored (other than the valid xmm fields according to <a class="el" href="dr__ir__utils_8h.html#a5921c4f301ea05885f305f9a30b3c0b0">dr_mcontext_xmm_fields_valid()</a>, if DR_MC_MULTIMEDIA is specified in the flags field). The caller should instead manually save and restore the floating point state with <a class="el" href="dr__proc_8h.html#a4a11c9d5d127ce126562ad35b4d165dd">proc_save_fpstate()</a> and <a class="el" href="dr__proc_8h.html#a23edceee5d1ae7c7d51a212432e6d644">proc_restore_fpstate()</a> if necessary.</dd>
<dd>
If the caller wishes to set any other state (such as xmm registers that are not part of the mcontext) they may do so by just setting that state in the current thread before making this call. To set system data structures, use <a class="el" href="dr__tools_8h.html#aa2944aa54d591a236f5334a35bfb41bf">dr_switch_to_app_state()</a>, make the changes, and then switch back with <a class="el" href="dr__tools_8h.html#a97ba972c50a47e7121c98652b461ae8e">dr_switch_to_dr_state()</a> before calling this routine.</dd>
<dd>
This routine may only be called from a clean call from the cache. It can not be called from any registered event callback except the exception event (<a class="el" href="dr__events_8h.html#a69adae9409a1871149da69e97747b84c">dr_register_exception_event()</a>). From a signal event callback, use the DR_SIGNAL_REDIRECT return value rather than calling this routine.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if unsuccessful; if successful, does not return. </dd></dl>

</div>
</div>
<a class="anchor" id="aa101c165975f98f274d0a676136bb32d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* dr_redirect_native_target </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the target to use for a native context transfer to a target application address.</p>
<p>Normally, redirection is performed from a client context in a clean call or event callback by invoking <a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution()</a>. In some circumstances, redirection from an application (or "native") context is desirable without creating an application control transfer in a basic block.</p>
<p>To accomplish such a redirection, store the target application address in <a class="el" href="dr__ir__utils_8h.html#a85e6559244f2fc5b84c7a07f04168bad">SPILL_SLOT_REDIRECT_NATIVE_TGT</a> by calling <a class="el" href="dr__ir__utils_8h.html#abf8d50d718883a1caf6a2de0fb3dbce3">dr_write_saved_reg()</a>. Set up any other application state as desired directly in the current machine context. Then jump to the target returned by this routine. By default, the target is global and can be cached globally. However, if traces are thread-private, or if traces are disabled and basic blocks are thread-private, there will be a separate target per <code>drcontext</code>.</p>
<p>If a basic block is exited via such a redirection, the block should be emitted with the flag DR_EMIT_MUST_END_TRACE in order to avoid trace building errors.</p>
<p>Returns null on error. </p>

</div>
</div>
<a class="anchor" id="a5eab608c134db044f2d9453a8407d470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopnd__t.html">opnd_t</a> dr_reg_spill_slot_opnd </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an <a class="el" href="structopnd__t.html">opnd_t</a> that directly accesses the spill slot <code>slot</code>. Only slots &lt;= <a class="el" href="dr__ir__utils_8h.html#a762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot()</a> can be used with this routine. </p>
<dl class="section note"><dt>Note</dt><dd><code>slot</code> must be &lt;= <a class="el" href="dr__ir__utils_8h.html#a762389f8ae9d809fd7b8f1418cdbd5ae">dr_max_opnd_accessible_spill_slot()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9a2c851eeeee7e669f3e6a7b877977d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_restore_app_stack </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore into esp the value saved by <a class="el" href="dr__ir__utils_8h.html#a9647e1300201596bc818ca33c95d4cc6">dr_swap_to_clean_stack()</a>. </p>

</div>
</div>
<a class="anchor" id="a563b0de37a51cb2e84337deef30a57cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_restore_arith_flags </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore the 6 arithmetic flags, assuming they were saved using <a class="el" href="dr__ir__utils_8h.html#a44636ca6809a9fb22cf817701de9ee09">dr_save_arith_flags()</a> with slot <code>slot</code> and that xax holds the same value it did after the save.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>This routine is equivalent to <a class="el" href="dr__ir__utils_8h.html#ab69b4cb9ffac510fbfceab08472de13e">dr_restore_arith_flags_from_xax()</a> followed by <a class="el" href="dr__ir__utils_8h.html#a453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab69b4cb9ffac510fbfceab08472de13e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_restore_arith_flags_from_xax </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore the 6 arithmetic flags from xax. This currently uses DynamoRIO's "add $0x7f %al ;
sahf" code sequence, which is faster and easier than popf. The caller must ensure that xax contains the arithmetic flags, most likely from <a class="el" href="dr__ir__utils_8h.html#a0cbf1b9557d56d555bbdaae525b0992d">dr_save_arith_flags_to_xax()</a>. </p>

</div>
</div>
<a class="anchor" id="a453bc3ecddb4298ffdc1c429f30881b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_restore_reg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to restore the register <code>reg</code> from the spill slot <code>slot</code>. See <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a> for notes on lifetime and alternative access to spill slots. </p>

</div>
</div>
<a class="anchor" id="a44636ca6809a9fb22cf817701de9ee09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_save_arith_flags </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the 6 arithmetic flags into xax after first saving xax to the spill slot <code>slot</code>. This is equivalent to <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a> of xax to <code>slot</code> followed by lahf and seto al instructions. See <a class="el" href="dr__ir__utils_8h.html#a563b0de37a51cb2e84337deef30a57cf">dr_restore_arith_flags()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>At completion of the inserted instructions the saved flags are in the xax register. The xax register should not be modified after using this routine unless it is first saved (and later restored prior to using <a class="el" href="dr__ir__utils_8h.html#a563b0de37a51cb2e84337deef30a57cf">dr_restore_arith_flags()</a>).</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>This routine is equivalent to <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a> followed by <a class="el" href="dr__ir__utils_8h.html#a0cbf1b9557d56d555bbdaae525b0992d">dr_save_arith_flags_to_xax()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cbf1b9557d56d555bbdaae525b0992d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_save_arith_flags_to_xax </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the 6 arithmetic flags into xax. This currently uses DynamoRIO's "lahf ; seto al" code sequence, which is faster and easier than pushf. If the caller wishes to use xax between saving and restoring these flags, they must save and restore xax, potentially using <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a>/dr_restore_reg(). If the caller needs to save both the current value of xax and the flags stored to xax by this routine, they must use separate spill slots, or they will overwrite the original xax value in memory.</p>
<dl class="section warning"><dt>Warning</dt><dd>Clobbers xax; the caller must ensure xax is dead or saved at <code>where</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af294ac021c84f5ec47230ee7df0e6c02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_save_reg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the register <code>reg</code> in the spill slot <code>slot</code>. See <a class="el" href="dr__ir__utils_8h.html#a453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg()</a>. Use <a class="el" href="dr__ir__utils_8h.html#abb63ecfaa5256688bab9a2921fc19227">dr_read_saved_reg()</a> and <a class="el" href="dr__ir__utils_8h.html#abf8d50d718883a1caf6a2de0fb3dbce3">dr_write_saved_reg()</a> to access spill slots from clean calls and restore_state_events (see <a class="el" href="dr__events_8h.html#ae7a179ac7a2d01157e1ab2852f50c902">dr_register_restore_state_event()</a>). </p>
<dl class="section note"><dt>Note</dt><dd>The stored value remains available only until the next non-meta (i.e. application) instruction. Use <a class="el" href="dr__ir__utils_8h.html#a982089284bd51339f448ec4b3928d3b4">dr_insert_write_tls_field()</a> and <a class="el" href="dr__ir__utils_8h.html#a3831354cc7402d68719d8055fb3e9931">dr_insert_read_tls_field()</a> for a persistent (but more costly to access) thread-local-storage location. See also <a class="el" href="dr__tools_8h.html#a95b53d79cae021a473c39f3b2662323f">dr_raw_tls_calloc()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a56568d24667f5d64264d0bad398727b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_set_mcontext </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the fields of the application machine context selected by the flags field of <code>context</code> to the values in <code>context</code>.</p>
<p>This routine may only be called from:</p>
<ul>
<li>A clean call invoked by <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> or <a class="el" href="dr__ir__utils_8h.html#a4608ec2db2a288aa5e2a53bb6d19054d">dr_prepare_for_call()</a></li>
<li>A pre- or post-syscall event (<a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>, <a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) <a class="el" href="dr__events_8h.html#a0b0c102bb9a99d67c3e62ea8b3790ff1">dr_register_thread_exit_event()</a>)</li>
<li>Basic block or trace creation events (<a class="el" href="dr__events_8h.html#a043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a>, <a class="el" href="dr__events_8h.html#a88a19a6822654caf18c017e145f48a57">dr_register_trace_event()</a>), but for basic block creation only when the basic block callback parameters <code>for_trace</code> and <code>translating</code> are false, and for trace creation only when <code>translating</code> is false.</li>
</ul>
<p>Ignores the pc field.</p>
<p>If the size field of <code>context</code> is invalid, this routine will return false. A dr_mcontext_t obtained from DR will have the size field set.</p>
<p>The flags field of <code>context</code> must be set to select the desired fields for copying, using the dr_mcontext_flags_t values. Asking to copy multimedia registers incurs a higher performance cost. An invalid flags value will return false.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The xmm fields are only set for processes where the underlying processor supports them (and when DR_MC_MULTIMEDIA is set in the flags field). For <a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> that requested <code>save_fpstate</code>, the xmm values set here override that saved state. Use <a class="el" href="dr__ir__utils_8h.html#a5921c4f301ea05885f305f9a30b3c0b0">dr_mcontext_xmm_fields_valid()</a> to determine whether the xmm fields are valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a9647e1300201596bc818ca33c95d4cc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_swap_to_clean_stack </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into <code>ilist</code> prior to <code>where</code> meta-instruction(s) to save the current esp and switch to this thread's DR stack. </p>
<dl class="section note"><dt>Note</dt><dd>The DR stack is limited to 20KB by default; this can be changed with the -stack_size DR runtime parameter. This stack cannot be used to store state that persists beyond a single clean call, code cache execution, or probe callback function execution. </dd></dl>

</div>
</div>
<a class="anchor" id="abf8d50d718883a1caf6a2de0fb3dbce3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_write_saved_reg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a>&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Can be used from a clean call to modify the value saved in the spill slot <code>slot</code> by <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a> such that a later <a class="el" href="dr__ir__utils_8h.html#a453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg()</a> will see the new value.</p>
<dl class="section note"><dt>Note</dt><dd>This routine should only be used during a clean call out of the cache. Use at any other time could corrupt application or DynamoRIO state. </dd></dl>

</div>
</div>
<a class="anchor" id="aa18c8ca0720c97403a0fa9371ae792e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool get_x86_mode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The decode and encode routines use a per-thread persistent flag that indicates whether to treat code as 32-bit (x86) or 64-bit (x64). This routine returns the value of that flag.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a824eaa9075a7aaf443b4cc4180eec81e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_append </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction onto the end of <code>ilist</code> </p>

</div>
</div>
<a class="anchor" id="a94a1526c7b520c9aefbd775adfc57108"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_fault_append </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#a94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault()</a>) onto the end of <code>ilist</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>Essentially equivalent to <a class="el" href="dr__ir__utils_8h.html#a824eaa9075a7aaf443b4cc4180eec81e">instrlist_meta_append()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6ea095671bab4239c659d17d4a9cda56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_fault_postinsert </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#a94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault()</a>) into <code>ilist</code> after <code>where</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>Essentially equivalent to <a class="el" href="dr__ir__utils_8h.html#a98218650e1f61b58c5478cf68e25d9da">instrlist_meta_postinsert()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="affe811040a2962e5c6920a3c523212ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_fault_preinsert </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#a94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault()</a>) into <code>ilist</code> prior to <code>where</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Essentially equivalent to <a class="el" href="dr__ir__utils_8h.html#a3b0b7e9e09a9a85ca1a707da3ded6f69">instrlist_meta_preinsert()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a98218650e1f61b58c5478cf68e25d9da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_postinsert </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction into <code>ilist</code> after <code>where</code>. </p>

</div>
</div>
<a class="anchor" id="a3b0b7e9e09a9a85ca1a707da3ded6f69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instrlist_meta_preinsert </td>
          <td>(</td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts <code>instr</code> as a non-application instruction into <code>ilist</code> prior to <code>where</code>. </p>

</div>
</div>
<a class="anchor" id="adf9a4f63eafc7f9725f7d5bf1725ab5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool set_x86_mode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>x86</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The decode and encode routines use a per-thread persistent flag that indicates whether to treat code as 32-bit (x86) or 64-bit (x64). This routine sets that flag to the indicated value and returns the old value. Be sure to restore the old value prior to any further application execution to avoid problems in mis-interpreting application code.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_87d0e4dd236e354ebe37d9465555a8e6.html">include</a></li><li class="navelem"><a class="el" href="dr__ir__utils_8h.html">dr_ir_utils.h</a></li>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO API version 5.0.0 --- Wed Sep 10 2014 21:36:19 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
