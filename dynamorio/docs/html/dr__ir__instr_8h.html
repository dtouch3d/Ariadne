<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>DynamoRIO API: dr_ir_instr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO API
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dr__ir__instr_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dr_ir_instr.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions to create and manipulate instructions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__instr__label__data__t.html">_dr_instr_label_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:add002513aebf166b7fdae13d22828d8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#add002513aebf166b7fdae13d22828d8d">EFLAGS_READ_CF</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:add002513aebf166b7fdae13d22828d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa533378650b8a86c903410a8abe5789"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#afa533378650b8a86c903410a8abe5789">EFLAGS_READ_PF</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:afa533378650b8a86c903410a8abe5789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c54ddcc858950e361725de7bc870d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a43c54ddcc858950e361725de7bc870d6">EFLAGS_READ_AF</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="separator:a43c54ddcc858950e361725de7bc870d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8385b4d8340260aad30cf5b8455a4efd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8385b4d8340260aad30cf5b8455a4efd">EFLAGS_READ_ZF</a>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="separator:a8385b4d8340260aad30cf5b8455a4efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e0eb52c091f04e29148ca5e7ae2199"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae9e0eb52c091f04e29148ca5e7ae2199">EFLAGS_READ_SF</a>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="separator:ae9e0eb52c091f04e29148ca5e7ae2199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf7d3cf0c4e6b2f39c3a07533419837"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aebf7d3cf0c4e6b2f39c3a07533419837">EFLAGS_READ_TF</a>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="separator:aebf7d3cf0c4e6b2f39c3a07533419837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a57b4b5098e1ff53bb8a990eec54a14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5a57b4b5098e1ff53bb8a990eec54a14">EFLAGS_READ_IF</a>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="separator:a5a57b4b5098e1ff53bb8a990eec54a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241f4fe5f01af11fe8e9489fcf84ab4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a241f4fe5f01af11fe8e9489fcf84ab4a">EFLAGS_READ_DF</a>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="separator:a241f4fe5f01af11fe8e9489fcf84ab4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5f953da018e1530879109cb78095b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5b5f953da018e1530879109cb78095b0">EFLAGS_READ_OF</a>&#160;&#160;&#160;0x00000100</td></tr>
<tr class="separator:a5b5f953da018e1530879109cb78095b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70baddbcff9ed31c328376956f7b0ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab70baddbcff9ed31c328376956f7b0ea">EFLAGS_READ_NT</a>&#160;&#160;&#160;0x00000200</td></tr>
<tr class="separator:ab70baddbcff9ed31c328376956f7b0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e4b47d88d4014fedaed25482d39b34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a14e4b47d88d4014fedaed25482d39b34">EFLAGS_READ_RF</a>&#160;&#160;&#160;0x00000400</td></tr>
<tr class="separator:a14e4b47d88d4014fedaed25482d39b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafb04c014284b3c4b51b0c6d17be085"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#afafb04c014284b3c4b51b0c6d17be085">EFLAGS_WRITE_CF</a>&#160;&#160;&#160;0x00000800</td></tr>
<tr class="separator:afafb04c014284b3c4b51b0c6d17be085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302bd46f54cf696a1039c5d25f68bd02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a302bd46f54cf696a1039c5d25f68bd02">EFLAGS_WRITE_PF</a>&#160;&#160;&#160;0x00001000</td></tr>
<tr class="separator:a302bd46f54cf696a1039c5d25f68bd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0d29af655c408ddc915cc07c8ac95e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9e0d29af655c408ddc915cc07c8ac95e">EFLAGS_WRITE_AF</a>&#160;&#160;&#160;0x00002000</td></tr>
<tr class="separator:a9e0d29af655c408ddc915cc07c8ac95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5329db528d9d749deae463b9b8edd736"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5329db528d9d749deae463b9b8edd736">EFLAGS_WRITE_ZF</a>&#160;&#160;&#160;0x00004000</td></tr>
<tr class="separator:a5329db528d9d749deae463b9b8edd736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5ddab727f9e2c9d49f20bcfd07807b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a6b5ddab727f9e2c9d49f20bcfd07807b">EFLAGS_WRITE_SF</a>&#160;&#160;&#160;0x00008000</td></tr>
<tr class="separator:a6b5ddab727f9e2c9d49f20bcfd07807b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1ee8f92225d554aba043211c34e18b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aac1ee8f92225d554aba043211c34e18b">EFLAGS_WRITE_TF</a>&#160;&#160;&#160;0x00010000</td></tr>
<tr class="separator:aac1ee8f92225d554aba043211c34e18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61834da87126c5c1b3b5b89a1bb254e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab61834da87126c5c1b3b5b89a1bb254e">EFLAGS_WRITE_IF</a>&#160;&#160;&#160;0x00020000</td></tr>
<tr class="separator:ab61834da87126c5c1b3b5b89a1bb254e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb180e5ea86b98e6bbd65708e202e6f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#abb180e5ea86b98e6bbd65708e202e6f1">EFLAGS_WRITE_DF</a>&#160;&#160;&#160;0x00040000</td></tr>
<tr class="separator:abb180e5ea86b98e6bbd65708e202e6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8edc641bb696aceadb34b6d5179761"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a3d8edc641bb696aceadb34b6d5179761">EFLAGS_WRITE_OF</a>&#160;&#160;&#160;0x00080000</td></tr>
<tr class="separator:a3d8edc641bb696aceadb34b6d5179761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533d9a5cd836be7bd8f831256b9d407e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a533d9a5cd836be7bd8f831256b9d407e">EFLAGS_WRITE_NT</a>&#160;&#160;&#160;0x00100000</td></tr>
<tr class="separator:a533d9a5cd836be7bd8f831256b9d407e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad8fd64cd98ac35c20265b54de97cf2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1ad8fd64cd98ac35c20265b54de97cf2">EFLAGS_WRITE_RF</a>&#160;&#160;&#160;0x00200000</td></tr>
<tr class="separator:a1ad8fd64cd98ac35c20265b54de97cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d4ed7d7b9c544c09c395872a86c0ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a88d4ed7d7b9c544c09c395872a86c0ea">EFLAGS_READ_ALL</a>&#160;&#160;&#160;0x000007ff</td></tr>
<tr class="separator:a88d4ed7d7b9c544c09c395872a86c0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5727b7a5773bace9d656e4b969d7fce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab5727b7a5773bace9d656e4b969d7fce">EFLAGS_WRITE_ALL</a>&#160;&#160;&#160;0x003ff800</td></tr>
<tr class="separator:ab5727b7a5773bace9d656e4b969d7fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61b67b227ebe0012829621c25ca65f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad61b67b227ebe0012829621c25ca65f5">EFLAGS_READ_6</a>&#160;&#160;&#160;0x0000011f</td></tr>
<tr class="separator:ad61b67b227ebe0012829621c25ca65f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8287fcf9cd6cd2338a57c54e45b08a7f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8287fcf9cd6cd2338a57c54e45b08a7f">EFLAGS_WRITE_6</a>&#160;&#160;&#160;0x0008f800</td></tr>
<tr class="separator:a8287fcf9cd6cd2338a57c54e45b08a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1cca9ca8d0514a42f66c081f478231"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2f1cca9ca8d0514a42f66c081f478231">EFLAGS_WRITE_TO_READ</a>(x)&#160;&#160;&#160;((x) &gt;&gt; 11)</td></tr>
<tr class="separator:a2f1cca9ca8d0514a42f66c081f478231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe5d20458bd272fdeac681706c4bd14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#afbe5d20458bd272fdeac681706c4bd14">EFLAGS_READ_TO_WRITE</a>(x)&#160;&#160;&#160;((x) &lt;&lt; 11)</td></tr>
<tr class="separator:afbe5d20458bd272fdeac681706c4bd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697ecea613b828838ff6f08b88adf1d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a697ecea613b828838ff6f08b88adf1d2">PREFIX_LOCK</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:a697ecea613b828838ff6f08b88adf1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6a144b4030140faa950fe65fe9002d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a0e6a144b4030140faa950fe65fe9002d">PREFIX_JCC_NOT_TAKEN</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a0e6a144b4030140faa950fe65fe9002d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327356db32ce7a884e9a516b2d91b738"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a327356db32ce7a884e9a516b2d91b738">PREFIX_JCC_TAKEN</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:a327356db32ce7a884e9a516b2d91b738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c11ed8105a5cecf5345ab5262a784f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac3c11ed8105a5cecf5345ab5262a784f">PREFIX_XACQUIRE</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:ac3c11ed8105a5cecf5345ab5262a784f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba06eaa86f6bbe22f58a1e2ddffb33da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aba06eaa86f6bbe22f58a1e2ddffb33da">PREFIX_XRELEASE</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:aba06eaa86f6bbe22f58a1e2ddffb33da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af29c184442681322a7a77ab2a48ba889"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct__dr__instr__label__data__t.html">_dr_instr_label_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af29c184442681322a7a77ab2a48ba889">dr_instr_label_data_t</a></td></tr>
<tr class="separator:af29c184442681322a7a77ab2a48ba889"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a192e9ddf90889e6de003d95ebdaa7beb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beb">dr_fp_type_t</a> { <br/>
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beba47d09b15b2ec78db7ce84ae6ddf333b0">DR_FP_STATE</a>, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beba973de5b2ea84fb3da6db3e2b5f8ec5e3">DR_FP_MOVE</a>, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beba24a7a4e2a7b4558a1e2a26b690c5b6c7">DR_FP_CONVERT</a>, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beba20c0efa9e59f5424338edcbae638c6d3">DR_FP_MATH</a>
<br/>
 }</td></tr>
<tr class="separator:a192e9ddf90889e6de003d95ebdaa7beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb49720dc49f7d4e4cf9adbf2948e409"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#adb49720dc49f7d4e4cf9adbf2948e409aef9a85103f89f1abdcbc577177fe59dc">EFLAGS_CF</a> = 0x00000001, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#adb49720dc49f7d4e4cf9adbf2948e409abd82d6f3c93948e598947c3e60c5ffbe">EFLAGS_PF</a> = 0x00000004, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#adb49720dc49f7d4e4cf9adbf2948e409ae02f888626e1c77d3dadb0c69c4ccebe">EFLAGS_AF</a> = 0x00000010, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#adb49720dc49f7d4e4cf9adbf2948e409aeb567fc9958d98e114e2aed3f73e6cf1">EFLAGS_ZF</a> = 0x00000040, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#adb49720dc49f7d4e4cf9adbf2948e409a607506a5fd2d021972d2f7ecb397960f">EFLAGS_SF</a> = 0x00000080, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#adb49720dc49f7d4e4cf9adbf2948e409ad3cf0d7affac2713bfcb915f809200da">EFLAGS_DF</a> = 0x00000400, 
<br/>
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#adb49720dc49f7d4e4cf9adbf2948e409ad4d56500271d500e241e46fdd7fdddb4">EFLAGS_OF</a> = 0x00000800
<br/>
 }</td></tr>
<tr class="separator:adb49720dc49f7d4e4cf9adbf2948e409"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a56419903595cc4bd2bb39f887a5275d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a56419903595cc4bd2bb39f887a5275d5">instr_is_encoding_possible</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a56419903595cc4bd2bb39f887a5275d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd4d0740eb0a0bcd2d387685719263c"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1cd4d0740eb0a0bcd2d387685719263c">instr_encode</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *pc)</td></tr>
<tr class="separator:a1cd4d0740eb0a0bcd2d387685719263c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5356c2dd3388496158fa0a918f8c2a53"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5356c2dd3388496158fa0a918f8c2a53">instr_encode_to_copy</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *copy_pc, byte *final_pc)</td></tr>
<tr class="separator:a5356c2dd3388496158fa0a918f8c2a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f53f3c43c91833faf11b5e6cd9e905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a65f53f3c43c91833faf11b5e6cd9e905">instr_create</a> (void *drcontext)</td></tr>
<tr class="separator:a65f53f3c43c91833faf11b5e6cd9e905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b55daa2b3780d2c07e33b8330b2f62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a77b55daa2b3780d2c07e33b8330b2f62">instr_init</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a77b55daa2b3780d2c07e33b8330b2f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f3cc7fb91265cb6c8eb15a84184c1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae0f3cc7fb91265cb6c8eb15a84184c1f">instr_free</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ae0f3cc7fb91265cb6c8eb15a84184c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd2bdee07d2e6ca0be3b252bc7b913f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#accd2bdee07d2e6ca0be3b252bc7b913f">instr_reset</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:accd2bdee07d2e6ca0be3b252bc7b913f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b44a1db49dc5cd8da8b6b27fa47d50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab9b44a1db49dc5cd8da8b6b27fa47d50">instr_reuse</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ab9b44a1db49dc5cd8da8b6b27fa47d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb082bbf9ac73968667b79b4cd14d73f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#acb082bbf9ac73968667b79b4cd14d73f">instr_destroy</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:acb082bbf9ac73968667b79b4cd14d73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a11b5b0700f7601087e2fda87175040"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE <a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9a11b5b0700f7601087e2fda87175040">instr_get_next</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a9a11b5b0700f7601087e2fda87175040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1114903afc8f9a3539aed43330117627"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE <a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1114903afc8f9a3539aed43330117627">instr_get_next_app</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a1114903afc8f9a3539aed43330117627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1432bded4f063c3c9d41f1a798f703b0"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE <a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1432bded4f063c3c9d41f1a798f703b0">instr_get_prev</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a1432bded4f063c3c9d41f1a798f703b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c3ae1eb25b05c337889022f35e6187"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa8c3ae1eb25b05c337889022f35e6187">instr_set_next</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="structinstr__t.html">instr_t</a> *next)</td></tr>
<tr class="separator:aa8c3ae1eb25b05c337889022f35e6187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208fe2bdba4a5ea47f1a0588fdc3278b"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a208fe2bdba4a5ea47f1a0588fdc3278b">instr_set_prev</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="structinstr__t.html">instr_t</a> *prev)</td></tr>
<tr class="separator:a208fe2bdba4a5ea47f1a0588fdc3278b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776a1fd0cf8f783b2a969a24432fee6e"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a776a1fd0cf8f783b2a969a24432fee6e">instr_get_note</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a776a1fd0cf8f783b2a969a24432fee6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a8f92faa0d368fec240e6fa819ca9c"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a85a8f92faa0d368fec240e6fa819ca9c">instr_set_note</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, void *value)</td></tr>
<tr class="separator:a85a8f92faa0d368fec240e6fa819ca9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c178ef16a57aa4c89976cb11419719"><td class="memItemLeft" align="right" valign="top">app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab4c178ef16a57aa4c89976cb11419719">instr_get_branch_target_pc</a> (<a class="el" href="structinstr__t.html">instr_t</a> *cti_instr)</td></tr>
<tr class="separator:ab4c178ef16a57aa4c89976cb11419719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1429cf1d1da8156898fde712e59e86db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1429cf1d1da8156898fde712e59e86db">instr_set_branch_target_pc</a> (<a class="el" href="structinstr__t.html">instr_t</a> *cti_instr, app_pc pc)</td></tr>
<tr class="separator:a1429cf1d1da8156898fde712e59e86db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7abc869b82542e5ea0e564ec671b7cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad7abc869b82542e5ea0e564ec671b7cd">instr_is_exit_cti</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ad7abc869b82542e5ea0e564ec671b7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21d0c15479e3a0ee88a7ec06fe9eb22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa21d0c15479e3a0ee88a7ec06fe9eb22">instr_is_interrupt</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:aa21d0c15479e3a0ee88a7ec06fe9eb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6d7eea24e55c4a4851ab4e3c0aa108"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5e6d7eea24e55c4a4851ab4e3c0aa108">instr_is_app</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a5e6d7eea24e55c4a4851ab4e3c0aa108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d47ceb0c0c0b5f50b78346c85a7f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab7d47ceb0c0c0b5f50b78346c85a7f47">instr_set_app</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ab7d47ceb0c0c0b5f50b78346c85a7f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03f60b3110fcbd793381245bed502be"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad03f60b3110fcbd793381245bed502be">instr_is_meta</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ad03f60b3110fcbd793381245bed502be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0919782b67d3918ec6feb838e373f15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad0919782b67d3918ec6feb838e373f15">instr_set_meta</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ad0919782b67d3918ec6feb838e373f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95454ba978870e70aa6b882155c4dabd"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a95454ba978870e70aa6b882155c4dabd">instr_ok_to_mangle</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a95454ba978870e70aa6b882155c4dabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2335bd8d05936e8308506ef11f1be401"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2335bd8d05936e8308506ef11f1be401">instr_set_ok_to_mangle</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool val)</td></tr>
<tr class="separator:a2335bd8d05936e8308506ef11f1be401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5206d055a5b06435bd5e919da40e8bd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5206d055a5b06435bd5e919da40e8bd4">instr_set_meta_no_translation</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a5206d055a5b06435bd5e919da40e8bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221092e79cb7fd9a701c2e260685a6dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a221092e79cb7fd9a701c2e260685a6dc">instr_ok_to_emit</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a221092e79cb7fd9a701c2e260685a6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34605a2cff286d358941be6aa91788d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae34605a2cff286d358941be6aa91788d">instr_set_ok_to_emit</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool val)</td></tr>
<tr class="separator:ae34605a2cff286d358941be6aa91788d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0e57a48576a4aac25b1554f6ebcbf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ace0e57a48576a4aac25b1554f6ebcbf7">instr_length</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ace0e57a48576a4aac25b1554f6ebcbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af679a00bb888cbb46ae266a8591997ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af679a00bb888cbb46ae266a8591997ea">instr_mem_usage</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:af679a00bb888cbb46ae266a8591997ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c874bf0f8b67dd6a85f2d54c1e87dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af8c874bf0f8b67dd6a85f2d54c1e87dc">instr_clone</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *orig)</td></tr>
<tr class="separator:af8c874bf0f8b67dd6a85f2d54c1e87dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ef462712287c564d125a71383a09c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a88ef462712287c564d125a71383a09c3">instr_build</a> (void *drcontext, int opcode, int num_dsts, int num_srcs)</td></tr>
<tr class="separator:a88ef462712287c564d125a71383a09c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947d5940c5e43001ee44577a05d433f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a947d5940c5e43001ee44577a05d433f5">instr_build_bits</a> (void *drcontext, int opcode, uint num_bytes)</td></tr>
<tr class="separator:a947d5940c5e43001ee44577a05d433f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9890dc9d4dbc40589c974a0ff221db72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9890dc9d4dbc40589c974a0ff221db72">instr_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a9890dc9d4dbc40589c974a0ff221db72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57dbc129ab88dfdcf49f1105eba394a7"><td class="memItemLeft" align="right" valign="top">app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a57dbc129ab88dfdcf49f1105eba394a7">instr_get_app_pc</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a57dbc129ab88dfdcf49f1105eba394a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d36984352b073089da3c91b901c853"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a90d36984352b073089da3c91b901c853">instr_get_opcode</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a90d36984352b073089da3c91b901c853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1efc53088af35fa0ed6eefd80af5dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5e1efc53088af35fa0ed6eefd80af5dd">instr_set_opcode</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, int opcode)</td></tr>
<tr class="separator:a5e1efc53088af35fa0ed6eefd80af5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f43bb8dee8ee7c8d07727247d3428b0"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2f43bb8dee8ee7c8d07727247d3428b0">instr_num_srcs</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a2f43bb8dee8ee7c8d07727247d3428b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c99383d4ffa44c28d6fed33b449b2f"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a41c99383d4ffa44c28d6fed33b449b2f">instr_num_dsts</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a41c99383d4ffa44c28d6fed33b449b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0d80a8e69e8f0abe867f1903a107ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aee0d80a8e69e8f0abe867f1903a107ea">instr_set_num_opnds</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, int num_dsts, int num_srcs)</td></tr>
<tr class="separator:aee0d80a8e69e8f0abe867f1903a107ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60219f08461b9bc143214c937893d98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa60219f08461b9bc143214c937893d98">instr_get_src</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos)</td></tr>
<tr class="separator:aa60219f08461b9bc143214c937893d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed999847d48a5a9eb1032239a660e398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aed999847d48a5a9eb1032239a660e398">instr_get_dst</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos)</td></tr>
<tr class="separator:aed999847d48a5a9eb1032239a660e398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bfa15e2f3a95174e36c80c585a24e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a96bfa15e2f3a95174e36c80c585a24e3">instr_set_src</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos, <a class="el" href="structopnd__t.html">opnd_t</a> opnd)</td></tr>
<tr class="separator:a96bfa15e2f3a95174e36c80c585a24e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e843e39613655f6a5c49e081fe593c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8e843e39613655f6a5c49e081fe593c2">instr_set_dst</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos, <a class="el" href="structopnd__t.html">opnd_t</a> opnd)</td></tr>
<tr class="separator:a8e843e39613655f6a5c49e081fe593c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff26384b57a52838dbd9b854db44cb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a6ff26384b57a52838dbd9b854db44cb6">instr_get_target</a> (<a class="el" href="structinstr__t.html">instr_t</a> *cti_instr)</td></tr>
<tr class="separator:a6ff26384b57a52838dbd9b854db44cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf4b84b7a6b07e22af66b0aec7cacf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#adbf4b84b7a6b07e22af66b0aec7cacf5">instr_set_target</a> (<a class="el" href="structinstr__t.html">instr_t</a> *cti_instr, <a class="el" href="structopnd__t.html">opnd_t</a> target)</td></tr>
<tr class="separator:adbf4b84b7a6b07e22af66b0aec7cacf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c820f4c4b82638289cca3c40f1d15c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9c820f4c4b82638289cca3c40f1d15c0">instr_operands_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a9c820f4c4b82638289cca3c40f1d15c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f4d5f068f69df848c0dd1cacebc90f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac8f4d5f068f69df848c0dd1cacebc90f">instr_set_operands_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool valid)</td></tr>
<tr class="separator:ac8f4d5f068f69df848c0dd1cacebc90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaf6ea858ca81c8b9968e4be43749f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#afeaf6ea858ca81c8b9968e4be43749f6">instr_opcode_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:afeaf6ea858ca81c8b9968e4be43749f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af295aa1b99e3b1fb73562312fc547ce9"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af295aa1b99e3b1fb73562312fc547ce9">instr_get_eflags</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:af295aa1b99e3b1fb73562312fc547ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749df373b340acb6437fea2f02b2fe69"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a749df373b340acb6437fea2f02b2fe69">instr_get_opcode_eflags</a> (int opcode)</td></tr>
<tr class="separator:a749df373b340acb6437fea2f02b2fe69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23aa72462b20fa6349d2ca2289c0f9a3"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a23aa72462b20fa6349d2ca2289c0f9a3">instr_get_arith_flags</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a23aa72462b20fa6349d2ca2289c0f9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9c3a55529a9e5467851821fe53fdb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7b9c3a55529a9e5467851821fe53fdb2">instr_set_raw_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *addr, uint length)</td></tr>
<tr class="separator:a7b9c3a55529a9e5467851821fe53fdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b3326d827b06a1d1d0bc3d20ba17a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a76b3326d827b06a1d1d0bc3d20ba17a2">instr_set_raw_bits_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool valid)</td></tr>
<tr class="separator:a76b3326d827b06a1d1d0bc3d20ba17a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08de27201e4c64a655e309b47d096c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af08de27201e4c64a655e309b47d096c4">instr_raw_bits_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:af08de27201e4c64a655e309b47d096c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5ea7e7d0387d7d1461830c1e5253c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#add5ea7e7d0387d7d1461830c1e5253c3">instr_has_allocated_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:add5ea7e7d0387d7d1461830c1e5253c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8c87b75de66fe9fcdf3db864a08702"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#adb8c87b75de66fe9fcdf3db864a08702">instr_needs_encoding</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:adb8c87b75de66fe9fcdf3db864a08702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954715b40fa2668d7cde0c4a1bf47e51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a954715b40fa2668d7cde0c4a1bf47e51">instr_is_meta_may_fault</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a954715b40fa2668d7cde0c4a1bf47e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94227a193446d370f0180e6a844be0c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool val)</td></tr>
<tr class="separator:a94227a193446d370f0180e6a844be0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b33f34d4dd11993224b4fb10e136dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af7b33f34d4dd11993224b4fb10e136dc">instr_allocate_raw_bits</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, uint num_bytes)</td></tr>
<tr class="separator:af7b33f34d4dd11993224b4fb10e136dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1beda2d570ba04d74ca9cbd7c31bb1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, app_pc addr)</td></tr>
<tr class="separator:af1beda2d570ba04d74ca9cbd7c31bb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8620fe9a0391247fcd9183e7cac291c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8620fe9a0391247fcd9183e7cac291c3">instr_make_persistent</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a8620fe9a0391247fcd9183e7cac291c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964928ee44090aba9aef343c5d34df5c"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a964928ee44090aba9aef343c5d34df5c">instr_get_raw_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a964928ee44090aba9aef343c5d34df5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7af19aa3aadf7b05900a39ef62b01b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa7af19aa3aadf7b05900a39ef62b01b9">instr_free_raw_bits</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:aa7af19aa3aadf7b05900a39ef62b01b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d41e2a8da7c0ef207d269020053ecc"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af8d41e2a8da7c0ef207d269020053ecc">instr_get_raw_byte</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos)</td></tr>
<tr class="separator:af8d41e2a8da7c0ef207d269020053ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11045a1b7b7cbd2053048f028e5e687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad11045a1b7b7cbd2053048f028e5e687">instr_set_raw_byte</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos, byte byte)</td></tr>
<tr class="separator:ad11045a1b7b7cbd2053048f028e5e687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fba42e58fa08ed1e0da9be2fbde4d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a71fba42e58fa08ed1e0da9be2fbde4d4">instr_set_raw_bytes</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *start, uint num_bytes)</td></tr>
<tr class="separator:a71fba42e58fa08ed1e0da9be2fbde4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ea2d9c35a7b4fcf89e4d160314babb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a22ea2d9c35a7b4fcf89e4d160314babb">instr_set_raw_word</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos, uint word)</td></tr>
<tr class="separator:a22ea2d9c35a7b4fcf89e4d160314babb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d1b19bf4e736c6f361164a295160a6"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae0d1b19bf4e736c6f361164a295160a6">instr_get_raw_word</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos)</td></tr>
<tr class="separator:ae0d1b19bf4e736c6f361164a295160a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3948b6ce886753002699286061faef26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a3948b6ce886753002699286061faef26">instr_set_prefix_flag</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint prefix)</td></tr>
<tr class="separator:a3948b6ce886753002699286061faef26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3722cd7a5b3728b5edeefd4b07bd456c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a3722cd7a5b3728b5edeefd4b07bd456c">instr_get_prefix_flag</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint prefix)</td></tr>
<tr class="separator:a3722cd7a5b3728b5edeefd4b07bd456c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74814111812ff20b281f7350fb626746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a74814111812ff20b281f7350fb626746">instr_set_x86_mode</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool x86)</td></tr>
<tr class="separator:a74814111812ff20b281f7350fb626746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3a5a5abd40c0c0694f037fcfac5705"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#acf3a5a5abd40c0c0694f037fcfac5705">instr_get_x86_mode</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:acf3a5a5abd40c0c0694f037fcfac5705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dba2c8ede2bb35a708bd8dba95d5746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2dba2c8ede2bb35a708bd8dba95d5746">instr_shrink_to_16_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a2dba2c8ede2bb35a708bd8dba95d5746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0db1cec99a6fff7dde7201a87ca8892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae0db1cec99a6fff7dde7201a87ca8892">instr_shrink_to_32_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ae0db1cec99a6fff7dde7201a87ca8892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a3336a497835085cc0a7be3b010cf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a15a3336a497835085cc0a7be3b010cf3">instr_uses_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_id_t reg)</td></tr>
<tr class="separator:a15a3336a497835085cc0a7be3b010cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b828bdfc3723d5b05d7147cfc237397"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9b828bdfc3723d5b05d7147cfc237397">instr_uses_fp_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a9b828bdfc3723d5b05d7147cfc237397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1092dee2d8367ca2fec50cba5e632d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae1092dee2d8367ca2fec50cba5e632d0">instr_reg_in_src</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_id_t reg)</td></tr>
<tr class="separator:ae1092dee2d8367ca2fec50cba5e632d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0752a69bd5b0331f8e98512ec15c2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7e0752a69bd5b0331f8e98512ec15c2b">instr_reg_in_dst</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_id_t reg)</td></tr>
<tr class="separator:a7e0752a69bd5b0331f8e98512ec15c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2d116d97b3cbb47895984077119cfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2b2d116d97b3cbb47895984077119cfa">instr_writes_to_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_id_t reg)</td></tr>
<tr class="separator:a2b2d116d97b3cbb47895984077119cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5229b3775a4b2cdaa9aa257a27a0be1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5229b3775a4b2cdaa9aa257a27a0be1a">instr_reads_from_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_id_t reg)</td></tr>
<tr class="separator:a5229b3775a4b2cdaa9aa257a27a0be1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5a8131ed782adc6f31471417b88da9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2d5a8131ed782adc6f31471417b88da9">instr_writes_to_exact_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_id_t reg)</td></tr>
<tr class="separator:a2d5a8131ed782adc6f31471417b88da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff0a9b43777e95bf6932260f4b5cc09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7ff0a9b43777e95bf6932260f4b5cc09">instr_replace_src_opnd</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="structopnd__t.html">opnd_t</a> old_opnd, <a class="el" href="structopnd__t.html">opnd_t</a> new_opnd)</td></tr>
<tr class="separator:a7ff0a9b43777e95bf6932260f4b5cc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e75c7fe47cb20acfae6bca1cd4bd2e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9e75c7fe47cb20acfae6bca1cd4bd2e0">instr_same</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr1, <a class="el" href="structinstr__t.html">instr_t</a> *instr2)</td></tr>
<tr class="separator:a9e75c7fe47cb20acfae6bca1cd4bd2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae408fe229bea0aa800cddb6b911c0e94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae408fe229bea0aa800cddb6b911c0e94">instr_reads_memory</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ae408fe229bea0aa800cddb6b911c0e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aac8cef8bb6ab075238e38ad6888a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae1aac8cef8bb6ab075238e38ad6888a9">instr_writes_memory</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ae1aac8cef8bb6ab075238e38ad6888a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785671aba1adec0f47add596f7e6a440"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a785671aba1adec0f47add596f7e6a440">instr_zeroes_ymmh</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a785671aba1adec0f47add596f7e6a440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2b7bfe6c9670ac127a24ea7aef33d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7c2b7bfe6c9670ac127a24ea7aef33d4">instr_has_rel_addr_reference</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a7c2b7bfe6c9670ac127a24ea7aef33d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b43ab8c3edd905329429075e91ea1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a19b43ab8c3edd905329429075e91ea1a">instr_get_rel_addr_target</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, app_pc *target)</td></tr>
<tr class="separator:a19b43ab8c3edd905329429075e91ea1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e4c9cbe4890f8e37af9e299affc86c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae9e4c9cbe4890f8e37af9e299affc86c">instr_get_rel_addr_dst_idx</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ae9e4c9cbe4890f8e37af9e299affc86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8942eef70af97b8018b31df431ef1822"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8942eef70af97b8018b31df431ef1822">instr_get_rel_addr_src_idx</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a8942eef70af97b8018b31df431ef1822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13ec559a17ab70816f80de784e5632f"><td class="memItemLeft" align="right" valign="top">app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa13ec559a17ab70816f80de784e5632f">instr_compute_address</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *mc)</td></tr>
<tr class="separator:aa13ec559a17ab70816f80de784e5632f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04322a189dd7f17ab245594e02cc6a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa04322a189dd7f17ab245594e02cc6a8">instr_compute_address_ex</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *mc, uint index, OUT app_pc *addr, OUT bool *write)</td></tr>
<tr class="separator:aa04322a189dd7f17ab245594e02cc6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25107e1fb5a49de3c627b70acc7b2eef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a25107e1fb5a49de3c627b70acc7b2eef">instr_compute_address_ex_pos</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *mc, uint index, OUT app_pc *addr, OUT bool *is_write, OUT uint *pos)</td></tr>
<tr class="separator:a25107e1fb5a49de3c627b70acc7b2eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67563b7baa993aa824ba1803562fc029"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a67563b7baa993aa824ba1803562fc029">instr_memory_reference_size</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a67563b7baa993aa824ba1803562fc029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eab5eaa85e186349d200a87e8010fec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__ir__instr_8h.html#af29c184442681322a7a77ab2a48ba889">dr_instr_label_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7eab5eaa85e186349d200a87e8010fec">instr_get_label_data_area</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a7eab5eaa85e186349d200a87e8010fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b39dade5681d6135379a5d53fe57512"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8b39dade5681d6135379a5d53fe57512">instr_is_mov</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a8b39dade5681d6135379a5d53fe57512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d347723617986e9424b042cb69495e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9d347723617986e9424b042cb69495e5">instr_is_call</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a9d347723617986e9424b042cb69495e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb0fc26f65991c24002df14abb7e461"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5cb0fc26f65991c24002df14abb7e461">instr_is_call_direct</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a5cb0fc26f65991c24002df14abb7e461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d172e2621d4548fe2c414fb0ed333a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a87d172e2621d4548fe2c414fb0ed333a">instr_is_near_call_direct</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a87d172e2621d4548fe2c414fb0ed333a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe1cc575e2870720ceee8ce134771f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1fe1cc575e2870720ceee8ce134771f3">instr_is_call_indirect</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a1fe1cc575e2870720ceee8ce134771f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade184d50e1016f220a10f40a60a4f8ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ade184d50e1016f220a10f40a60a4f8ad">instr_is_return</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ade184d50e1016f220a10f40a60a4f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076d0445255d4902181cb272bacd80aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a076d0445255d4902181cb272bacd80aa">instr_is_cti</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a076d0445255d4902181cb272bacd80aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2782471943558d57296b89a3f41a530d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2782471943558d57296b89a3f41a530d">instr_is_cti_short</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a2782471943558d57296b89a3f41a530d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af759611c486c5ac9e1a5336a809661"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4af759611c486c5ac9e1a5336a809661">instr_is_cti_loop</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a4af759611c486c5ac9e1a5336a809661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c61714f2632d46211d61ebb55d4bbde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8c61714f2632d46211d61ebb55d4bbde">instr_is_cti_short_rewrite</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *pc)</td></tr>
<tr class="separator:a8c61714f2632d46211d61ebb55d4bbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006c261a813d4e91fc25c549e5ebbb8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a006c261a813d4e91fc25c549e5ebbb8d">instr_is_cbr</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a006c261a813d4e91fc25c549e5ebbb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963ac2677038071fc295b3b6eb45ce1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a963ac2677038071fc295b3b6eb45ce1d">instr_is_mbr</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a963ac2677038071fc295b3b6eb45ce1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39c368adab3332628a34c1f48afc466"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac39c368adab3332628a34c1f48afc466">instr_is_ubr</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ac39c368adab3332628a34c1f48afc466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5541d2b9311f842c43c0cfca020eb5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab5541d2b9311f842c43c0cfca020eb5d">instr_is_near_ubr</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ab5541d2b9311f842c43c0cfca020eb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ee0433816dfcfbe8ca41988d757aee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a45ee0433816dfcfbe8ca41988d757aee">instr_is_far_cti</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a45ee0433816dfcfbe8ca41988d757aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83165c08bdab6b1bf0933bccba7d557"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac83165c08bdab6b1bf0933bccba7d557">instr_is_far_abs_cti</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ac83165c08bdab6b1bf0933bccba7d557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d982227aea8aa8647694b35cc592b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a86d982227aea8aa8647694b35cc592b3">instr_is_syscall</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a86d982227aea8aa8647694b35cc592b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4d5454f266483029bd88e5a17e398c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4a4d5454f266483029bd88e5a17e398c">instr_is_wow64_syscall</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a4a4d5454f266483029bd88e5a17e398c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa653a23cf2029fc4eeaf05eb7523849d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa653a23cf2029fc4eeaf05eb7523849d">instr_is_prefetch</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:aa653a23cf2029fc4eeaf05eb7523849d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8da7990fa33f321134102323546516b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac8da7990fa33f321134102323546516b">instr_is_mov_constant</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, ptr_int_t *value)</td></tr>
<tr class="separator:ac8da7990fa33f321134102323546516b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cdb64c78235caf707130680d1f156d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a81cdb64c78235caf707130680d1f156d">instr_is_floating</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a81cdb64c78235caf707130680d1f156d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac609abca95ab7f30d7f289f5dd19fdad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac609abca95ab7f30d7f289f5dd19fdad">instr_is_floating_ex</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beb">dr_fp_type_t</a> *type)</td></tr>
<tr class="separator:ac609abca95ab7f30d7f289f5dd19fdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e297cd513cbde904d0e09b721f1e9c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5e297cd513cbde904d0e09b721f1e9c1">instr_is_mmx</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a5e297cd513cbde904d0e09b721f1e9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33bb11334437a3076fbb81c0493f6e7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a33bb11334437a3076fbb81c0493f6e7a">instr_is_sse_or_sse2</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a33bb11334437a3076fbb81c0493f6e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf18b53c422fdb11efe7bdcc596aea2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1cf18b53c422fdb11efe7bdcc596aea2">instr_is_mov_imm_to_tos</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a1cf18b53c422fdb11efe7bdcc596aea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61355d1ac416d4f04ed286eebc7c251"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae61355d1ac416d4f04ed286eebc7c251">instr_is_label</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ae61355d1ac416d4f04ed286eebc7c251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465cc4935f184c4d224afbb9547a445c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a465cc4935f184c4d224afbb9547a445c">instr_is_undefined</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a465cc4935f184c4d224afbb9547a445c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784fcd66cdda36aaf218121f1b75ab2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a784fcd66cdda36aaf218121f1b75ab2d">instr_get_interrupt_number</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a784fcd66cdda36aaf218121f1b75ab2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc25aa34b90fcf0cdcfdbd8028464274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#acc25aa34b90fcf0cdcfdbd8028464274">instr_invert_cbr</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:acc25aa34b90fcf0cdcfdbd8028464274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a349e086f96bb03bd6700129dc6135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a33a349e086f96bb03bd6700129dc6135">instr_convert_short_meta_jmp_to_long</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a33a349e086f96bb03bd6700129dc6135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a9b2a0b21a18dbfd0a7a534204b92b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a79a9b2a0b21a18dbfd0a7a534204b92b">instr_jcc_taken</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_t eflags)</td></tr>
<tr class="separator:a79a9b2a0b21a18dbfd0a7a534204b92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222195624605490e7844ed3737ad3668"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a222195624605490e7844ed3737ad3668">instr_cmovcc_to_jcc</a> (int cmovcc_opcode)</td></tr>
<tr class="separator:a222195624605490e7844ed3737ad3668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238dc0a1168701e30a95b57dd0c845a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a238dc0a1168701e30a95b57dd0c845a0">instr_cmovcc_triggered</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_t eflags)</td></tr>
<tr class="separator:a238dc0a1168701e30a95b57dd0c845a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2c91a7868ad6a8e5c47af985edde61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#acb2c91a7868ad6a8e5c47af985edde61">instr_is_nop</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:acb2c91a7868ad6a8e5c47af985edde61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00a75c880108dde16b137370be5cedb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac00a75c880108dde16b137370be5cedb">instr_create_0dst_0src</a> (void *drcontext, int opcode)</td></tr>
<tr class="separator:ac00a75c880108dde16b137370be5cedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3835ac2d78ba9b90e1ced9c58cada5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad3835ac2d78ba9b90e1ced9c58cada5e">instr_create_0dst_1src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> src)</td></tr>
<tr class="separator:ad3835ac2d78ba9b90e1ced9c58cada5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d0c2cbad95bfe24daade84c6add8af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a54d0c2cbad95bfe24daade84c6add8af">instr_create_0dst_2src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2)</td></tr>
<tr class="separator:a54d0c2cbad95bfe24daade84c6add8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21033066f65f8dfd23ca24215ea99b70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a21033066f65f8dfd23ca24215ea99b70">instr_create_0dst_3src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3)</td></tr>
<tr class="separator:a21033066f65f8dfd23ca24215ea99b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db9f5f8dfd216fab6e9153170fb479f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4db9f5f8dfd216fab6e9153170fb479f">instr_create_1dst_0src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst)</td></tr>
<tr class="separator:a4db9f5f8dfd216fab6e9153170fb479f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0202b3cf63b50d16947f6be6f2b00891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a0202b3cf63b50d16947f6be6f2b00891">instr_create_1dst_1src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="structopnd__t.html">opnd_t</a> src)</td></tr>
<tr class="separator:a0202b3cf63b50d16947f6be6f2b00891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac469b18246e67b23f758c636f460d8ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac469b18246e67b23f758c636f460d8ac">instr_create_1dst_2src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2)</td></tr>
<tr class="separator:ac469b18246e67b23f758c636f460d8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a34019f73e797090b3ab9625cdbc5fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4a34019f73e797090b3ab9625cdbc5fc">instr_create_1dst_3src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3)</td></tr>
<tr class="separator:a4a34019f73e797090b3ab9625cdbc5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5a5241276ad8d2f392c7a1432efb61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4e5a5241276ad8d2f392c7a1432efb61">instr_create_1dst_5src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4, <a class="el" href="structopnd__t.html">opnd_t</a> src5)</td></tr>
<tr class="separator:a4e5a5241276ad8d2f392c7a1432efb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadd422dcd43564d40b43ca0e03b6910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aeadd422dcd43564d40b43ca0e03b6910">instr_create_2dst_0src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2)</td></tr>
<tr class="separator:aeadd422dcd43564d40b43ca0e03b6910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d0c6211ec93379e4ad6dc520506111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae6d0c6211ec93379e4ad6dc520506111">instr_create_2dst_1src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> src)</td></tr>
<tr class="separator:ae6d0c6211ec93379e4ad6dc520506111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c614653cadce1e2e6e567f3f68de6a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a3c614653cadce1e2e6e567f3f68de6a8">instr_create_2dst_2src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2)</td></tr>
<tr class="separator:a3c614653cadce1e2e6e567f3f68de6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711cac2989e3f2fa8fa702ce3b7f8ced"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a711cac2989e3f2fa8fa702ce3b7f8ced">instr_create_2dst_3src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3)</td></tr>
<tr class="separator:a711cac2989e3f2fa8fa702ce3b7f8ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608e02e275eb868cd09ba8c454d78b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a608e02e275eb868cd09ba8c454d78b5d">instr_create_2dst_4src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4)</td></tr>
<tr class="separator:a608e02e275eb868cd09ba8c454d78b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678839fc8b937d70b63be5fcbbb2d014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a678839fc8b937d70b63be5fcbbb2d014">instr_create_3dst_0src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3)</td></tr>
<tr class="separator:a678839fc8b937d70b63be5fcbbb2d014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f963b19ebe6ff70c0ea8174b53d9ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae5f963b19ebe6ff70c0ea8174b53d9ed">instr_create_3dst_3src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3)</td></tr>
<tr class="separator:ae5f963b19ebe6ff70c0ea8174b53d9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32078373abe0c5fb3f97774a936569d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a32078373abe0c5fb3f97774a936569d9">instr_create_3dst_4src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4)</td></tr>
<tr class="separator:a32078373abe0c5fb3f97774a936569d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee21bbcad5d7ee35f8828ed5244132fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aee21bbcad5d7ee35f8828ed5244132fd">instr_create_3dst_5src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4, <a class="el" href="structopnd__t.html">opnd_t</a> src5)</td></tr>
<tr class="separator:aee21bbcad5d7ee35f8828ed5244132fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b00a25f7ec49fbf943df0e9c667136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab8b00a25f7ec49fbf943df0e9c667136">instr_create_4dst_1src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> dst4, <a class="el" href="structopnd__t.html">opnd_t</a> src)</td></tr>
<tr class="separator:ab8b00a25f7ec49fbf943df0e9c667136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd02600b967d24951bc7208b6d70d459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#abd02600b967d24951bc7208b6d70d459">instr_create_4dst_4src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> dst4, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4)</td></tr>
<tr class="separator:abd02600b967d24951bc7208b6d70d459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa554f82d7fa8abd4f38dba90544c20ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa554f82d7fa8abd4f38dba90544c20ae">instr_create_popa</a> (void *drcontext)</td></tr>
<tr class="separator:aa554f82d7fa8abd4f38dba90544c20ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418865307bd5bd168cbde4ecd0f785a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a418865307bd5bd168cbde4ecd0f785a5">instr_create_pusha</a> (void *drcontext)</td></tr>
<tr class="separator:a418865307bd5bd168cbde4ecd0f785a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baf5239817b639791916f3cbd6c7b9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a6baf5239817b639791916f3cbd6c7b9d">instr_disassemble</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, file_t outfile)</td></tr>
<tr class="separator:a6baf5239817b639791916f3cbd6c7b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67ded4a34cef770ecc35e24e61813c8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af67ded4a34cef770ecc35e24e61813c8">instr_disassemble_to_buffer</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, char *buf, size_t bufsz)</td></tr>
<tr class="separator:af67ded4a34cef770ecc35e24e61813c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions to create and manipulate instructions. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ad61b67b227ebe0012829621c25ca65f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_6&#160;&#160;&#160;0x0000011f</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads all 6 arithmetic flags (CF, PF, AF, ZF, SF, OF). </p>

</div>
</div>
<a class="anchor" id="a43c54ddcc858950e361725de7bc870d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_AF&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads AF (Auxiliary Carry Flag). </p>

</div>
</div>
<a class="anchor" id="a88d4ed7d7b9c544c09c395872a86c0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_ALL&#160;&#160;&#160;0x000007ff</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads all flags. </p>

</div>
</div>
<a class="anchor" id="add002513aebf166b7fdae13d22828d8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_CF&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads CF (Carry Flag). </p>

</div>
</div>
<a class="anchor" id="a241f4fe5f01af11fe8e9489fcf84ab4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_DF&#160;&#160;&#160;0x00000080</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads DF (Direction Flag). </p>

</div>
</div>
<a class="anchor" id="a5a57b4b5098e1ff53bb8a990eec54a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_IF&#160;&#160;&#160;0x00000040</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads IF (Interrupt Enable Flag). </p>

</div>
</div>
<a class="anchor" id="ab70baddbcff9ed31c328376956f7b0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_NT&#160;&#160;&#160;0x00000200</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads NT (Nested Task). </p>

</div>
</div>
<a class="anchor" id="a5b5f953da018e1530879109cb78095b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_OF&#160;&#160;&#160;0x00000100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads OF (Overflow Flag). </p>

</div>
</div>
<a class="anchor" id="afa533378650b8a86c903410a8abe5789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_PF&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads PF (Parity Flag). </p>

</div>
</div>
<a class="anchor" id="a14e4b47d88d4014fedaed25482d39b34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_RF&#160;&#160;&#160;0x00000400</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads RF (Resume Flag). </p>

</div>
</div>
<a class="anchor" id="ae9e0eb52c091f04e29148ca5e7ae2199"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_SF&#160;&#160;&#160;0x00000010</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads SF (Sign Flag). </p>

</div>
</div>
<a class="anchor" id="aebf7d3cf0c4e6b2f39c3a07533419837"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_TF&#160;&#160;&#160;0x00000020</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads TF (Trap Flag). </p>

</div>
</div>
<a class="anchor" id="afbe5d20458bd272fdeac681706c4bd14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_TO_WRITE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((x) &lt;&lt; 11)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts an EFLAGS_READ_* value to the corresponding EFLAGS_WRITE_* value. </p>

</div>
</div>
<a class="anchor" id="a8385b4d8340260aad30cf5b8455a4efd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_ZF&#160;&#160;&#160;0x00000008</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads ZF (Zero Flag). </p>

</div>
</div>
<a class="anchor" id="a8287fcf9cd6cd2338a57c54e45b08a7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_6&#160;&#160;&#160;0x0008f800</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes all 6 arithmetic flags (CF, PF, AF, ZF, SF, OF). </p>

</div>
</div>
<a class="anchor" id="a9e0d29af655c408ddc915cc07c8ac95e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_AF&#160;&#160;&#160;0x00002000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes AF (Auxiliary Carry Flag). </p>

</div>
</div>
<a class="anchor" id="ab5727b7a5773bace9d656e4b969d7fce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_ALL&#160;&#160;&#160;0x003ff800</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes all flags. </p>

</div>
</div>
<a class="anchor" id="afafb04c014284b3c4b51b0c6d17be085"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_CF&#160;&#160;&#160;0x00000800</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes CF (Carry Flag). </p>

</div>
</div>
<a class="anchor" id="abb180e5ea86b98e6bbd65708e202e6f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_DF&#160;&#160;&#160;0x00040000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes DF (Direction Flag). </p>

</div>
</div>
<a class="anchor" id="ab61834da87126c5c1b3b5b89a1bb254e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_IF&#160;&#160;&#160;0x00020000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes IF (Interrupt Enable Flag). </p>

</div>
</div>
<a class="anchor" id="a533d9a5cd836be7bd8f831256b9d407e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_NT&#160;&#160;&#160;0x00100000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes NT (Nested Task). </p>

</div>
</div>
<a class="anchor" id="a3d8edc641bb696aceadb34b6d5179761"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_OF&#160;&#160;&#160;0x00080000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes OF (Overflow Flag). </p>

</div>
</div>
<a class="anchor" id="a302bd46f54cf696a1039c5d25f68bd02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_PF&#160;&#160;&#160;0x00001000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes PF (Parity Flag). </p>

</div>
</div>
<a class="anchor" id="a1ad8fd64cd98ac35c20265b54de97cf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_RF&#160;&#160;&#160;0x00200000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes RF (Resume Flag). </p>

</div>
</div>
<a class="anchor" id="a6b5ddab727f9e2c9d49f20bcfd07807b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_SF&#160;&#160;&#160;0x00008000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes SF (Sign Flag). </p>

</div>
</div>
<a class="anchor" id="aac1ee8f92225d554aba043211c34e18b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_TF&#160;&#160;&#160;0x00010000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes TF (Trap Flag). </p>

</div>
</div>
<a class="anchor" id="a2f1cca9ca8d0514a42f66c081f478231"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_TO_READ</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((x) &gt;&gt; 11)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts an EFLAGS_WRITE_* value to the corresponding EFLAGS_READ_* value. </p>

</div>
</div>
<a class="anchor" id="a5329db528d9d749deae463b9b8edd736"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_ZF&#160;&#160;&#160;0x00004000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes ZF (Zero Flag). </p>

</div>
</div>
<a class="anchor" id="a0e6a144b4030140faa950fe65fe9002d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFIX_JCC_NOT_TAKEN&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Branch hint: conditional branch is taken. </p>

</div>
</div>
<a class="anchor" id="a327356db32ce7a884e9a516b2d91b738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFIX_JCC_TAKEN&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Branch hint: conditional branch is not taken. </p>

</div>
</div>
<a class="anchor" id="a697ecea613b828838ff6f08b88adf1d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFIX_LOCK&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes the instruction's memory accesses atomic. </p>

</div>
</div>
<a class="anchor" id="ac3c11ed8105a5cecf5345ab5262a784f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFIX_XACQUIRE&#160;&#160;&#160;0x08</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transaction hint: start lock elision. </p>

</div>
</div>
<a class="anchor" id="aba06eaa86f6bbe22f58a1e2ddffb33da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFIX_XRELEASE&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transaction hint: end lock elision. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="af29c184442681322a7a77ab2a48ba889"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__instr__label__data__t.html">_dr_instr_label_data_t</a>  <a class="el" href="dr__ir__instr_8h.html#af29c184442681322a7a77ab2a48ba889">dr_instr_label_data_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data slots available in a label (instr_create_label()) instruction for storing client-controlled data. Accessible via <a class="el" href="dr__ir__instr_8h.html#a7eab5eaa85e186349d200a87e8010fec">instr_get_label_data_area()</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The actual bits in the eflags register that we care about:<br/>
</p>
<pre>
  11 10  9  8  7  6  5  4  3  2  1  0
  OF DF       SF ZF    AF    PF    CF  </pre> <table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409aef9a85103f89f1abdcbc577177fe59dc"></a>EFLAGS_CF</em>&#160;</td><td class="fielddoc">
<p>The bit in the eflags register of CF (Carry Flag). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409abd82d6f3c93948e598947c3e60c5ffbe"></a>EFLAGS_PF</em>&#160;</td><td class="fielddoc">
<p>The bit in the eflags register of PF (Parity Flag). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409ae02f888626e1c77d3dadb0c69c4ccebe"></a>EFLAGS_AF</em>&#160;</td><td class="fielddoc">
<p>The bit in the eflags register of AF (Aux Carry Flag). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409aeb567fc9958d98e114e2aed3f73e6cf1"></a>EFLAGS_ZF</em>&#160;</td><td class="fielddoc">
<p>The bit in the eflags register of ZF (Zero Flag). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409a607506a5fd2d021972d2f7ecb397960f"></a>EFLAGS_SF</em>&#160;</td><td class="fielddoc">
<p>The bit in the eflags register of SF (Sign Flag). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409ad3cf0d7affac2713bfcb915f809200da"></a>EFLAGS_DF</em>&#160;</td><td class="fielddoc">
<p>The bit in the eflags register of DF (Direction Flag). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adb49720dc49f7d4e4cf9adbf2948e409ad4d56500271d500e241e46fdd7fdddb4"></a>EFLAGS_OF</em>&#160;</td><td class="fielddoc">
<p>The bit in the eflags register of OF (Overflow Flag). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a192e9ddf90889e6de003d95ebdaa7beb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beb">dr_fp_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates which type of floating-point operation and instruction performs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a192e9ddf90889e6de003d95ebdaa7beba47d09b15b2ec78db7ce84ae6ddf333b0"></a>DR_FP_STATE</em>&#160;</td><td class="fielddoc">
<p>Loads, stores, or queries general floating point state. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a192e9ddf90889e6de003d95ebdaa7beba973de5b2ea84fb3da6db3e2b5f8ec5e3"></a>DR_FP_MOVE</em>&#160;</td><td class="fielddoc">
<p>Moves floating point values from one location to another. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a192e9ddf90889e6de003d95ebdaa7beba24a7a4e2a7b4558a1e2a26b690c5b6c7"></a>DR_FP_CONVERT</em>&#160;</td><td class="fielddoc">
<p>Converts to or from floating point values. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a192e9ddf90889e6de003d95ebdaa7beba20c0efa9e59f5424338edcbae638c6d3"></a>DR_FP_MATH</em>&#160;</td><td class="fielddoc">
<p>Performs arithmetic or conditional operations. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af7b33f34d4dd11993224b4fb10e136dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_allocate_raw_bits </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates <code>num_bytes</code> of memory for <code>instr's</code> raw bits. If <code>instr</code> currently points to raw bits, the allocated memory is initialized with the bytes pointed to. <code>instr</code> is then set to point to the allocated memory. </p>

</div>
</div>
<a class="anchor" id="a88ef462712287c564d125a71383a09c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_build </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_srcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine: calls</p>
<ul>
<li>instr_create(dcontext)</li>
<li>instr_set_opcode(opcode)</li>
<li>instr_set_num_opnds(dcontext, instr, num_dsts, num_srcs)</li>
</ul>
<p>and returns the resulting <a class="el" href="structinstr__t.html">instr_t</a>. </p>

</div>
</div>
<a class="anchor" id="a947d5940c5e43001ee44577a05d433f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_build_bits </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine: calls</p>
<ul>
<li>instr_create(dcontext)</li>
<li>instr_set_opcode(instr, opcode)</li>
<li>instr_allocate_raw_bits(dcontext, instr, num_bytes)</li>
</ul>
<p>and returns the resulting <a class="el" href="structinstr__t.html">instr_t</a>. </p>

</div>
</div>
<a class="anchor" id="af8c874bf0f8b67dd6a85f2d54c1e87dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_clone </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>orig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a copy of <code>orig</code> with separately allocated memory for operands and raw bytes if they were present in <code>orig</code>. Only a shallow copy of the <code>note</code> field is made. </p>

</div>
</div>
<a class="anchor" id="a222195624605490e7844ed3737ad3668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_cmovcc_to_jcc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmovcc_opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a cmovcc opcode <code>cmovcc_opcode</code> to the OP_jcc opcode that tests the same bits in eflags. </p>

</div>
</div>
<a class="anchor" id="a238dc0a1168701e30a95b57dd0c845a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_cmovcc_triggered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&#160;</td>
          <td class="paramname"><em>eflags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given <code>eflags</code>, returns whether or not the conditional move instruction <code>instr</code> would execute the move. The conditional move can be an OP_cmovcc or an OP_fcmovcc instruction. </p>

</div>
</div>
<a class="anchor" id="aa13ec559a17ab70816f80de784e5632f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc instr_compute_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>mc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns NULL if none of <code>instr's</code> operands is a memory reference. Otherwise, returns the effective address of the first memory operand when the operands are considered in this order: destinations and then sources. The address is computed using the passed-in registers. <code>mc-&gt;flags</code> must include DR_MC_CONTROL and DR_MC_INTEGER. For instructions that use vector addressing (VSIB, introduced in AVX2), mc-&gt;flags must additionally include DR_MC_MULTIMEDIA.</p>
<p>Like <a class="el" href="dr__ir__instr_8h.html#ae408fe229bea0aa800cddb6b911c0e94">instr_reads_memory()</a>, this routine does not consider multi-byte nops that use addressing operands, or the <a class="el" href="dr__ir__opcodes_8h.html#aae05225933a42f81e7c4a9fb286596f9a8e5722f2fffd08c1e03efa408a6a0f55">OP_lea</a> instruction's source operand, to be memory references. </p>

</div>
</div>
<a class="anchor" id="aa04322a189dd7f17ab245594e02cc6a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_compute_address_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT app_pc *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&#160;</td>
          <td class="paramname"><em>write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs address calculation in the same manner as <a class="el" href="dr__ir__instr_8h.html#aa13ec559a17ab70816f80de784e5632f">instr_compute_address()</a> but handles multiple memory operands. The <code>index</code> parameter should be initially set to 0 and then incremented with each successive call until this routine returns false, which indicates that there are no more memory operands. The address of each is computed in the same manner as <a class="el" href="dr__ir__instr_8h.html#aa13ec559a17ab70816f80de784e5632f">instr_compute_address()</a> and returned in <code>addr</code>; whether it is a write is returned in <code>is_write</code>. Either or both OUT variables can be NULL. <code>mc-&gt;flags</code> must include DR_MC_CONTROL and DR_MC_INTEGER. For instructions that use vector addressing (VSIB, introduced in AVX2), mc-&gt;flags must additionally include DR_MC_MULTIMEDIA.</p>
<p>Like <a class="el" href="dr__ir__instr_8h.html#ae408fe229bea0aa800cddb6b911c0e94">instr_reads_memory()</a>, this routine does not consider multi-byte nops that use addressing operands, or the <a class="el" href="dr__ir__opcodes_8h.html#aae05225933a42f81e7c4a9fb286596f9a8e5722f2fffd08c1e03efa408a6a0f55">OP_lea</a> instruction's source operand, to be memory references. </p>

</div>
</div>
<a class="anchor" id="a25107e1fb5a49de3c627b70acc7b2eef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_compute_address_ex_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT app_pc *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&#160;</td>
          <td class="paramname"><em>is_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs address calculation in the same manner as <a class="el" href="dr__ir__instr_8h.html#aa04322a189dd7f17ab245594e02cc6a8">instr_compute_address_ex()</a> with additional information of which opnd is used for address computation returned in <code>pos</code>. If <code>pos</code> is NULL, it is the same as <a class="el" href="dr__ir__instr_8h.html#aa04322a189dd7f17ab245594e02cc6a8">instr_compute_address_ex()</a>.</p>
<p>Like <a class="el" href="dr__ir__instr_8h.html#ae408fe229bea0aa800cddb6b911c0e94">instr_reads_memory()</a>, this routine does not consider multi-byte nops that use addressing operands, or the <a class="el" href="dr__ir__opcodes_8h.html#aae05225933a42f81e7c4a9fb286596f9a8e5722f2fffd08c1e03efa408a6a0f55">OP_lea</a> instruction's source operand, to be memory references. </p>

</div>
</div>
<a class="anchor" id="a33a349e086f96bb03bd6700129dc6135"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_convert_short_meta_jmp_to_long </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that instr is a meta instruction (<a class="el" href="dr__ir__instr_8h.html#ad03f60b3110fcbd793381245bed502be">instr_is_meta()</a>) and an <a class="el" href="dr__ir__instr_8h.html#a2782471943558d57296b89a3f41a530d">instr_is_cti_short()</a> (8-bit reach). Converts instr's opcode to a long form (32-bit reach). If instr's opcode is OP_loop* or OP_jecxz, converts it to a sequence of multiple instructions (which is different from <a class="el" href="dr__ir__instr_8h.html#a8c61714f2632d46211d61ebb55d4bbde">instr_is_cti_short_rewrite()</a>). Each added instruction is marked <a class="el" href="dr__ir__instr_8h.html#ad03f60b3110fcbd793381245bed502be">instr_is_meta()</a>. Returns the long form of the instruction, which is identical to <code>instr</code> unless <code>instr</code> is OP_loop* or OP_jecxz, in which case the return value is the final instruction in the sequence, the one that has long reach. </p>
<dl class="section note"><dt>Note</dt><dd>DR automatically converts app short ctis to long form. </dd></dl>

</div>
</div>
<a class="anchor" id="a65f53f3c43c91833faf11b5e6cd9e905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap. Sets the x86/x64 mode of the returned <a class="el" href="structinstr__t.html">instr_t</a> to the mode of dcontext. </p>

</div>
</div>
<a class="anchor" id="ac00a75c880108dde16b137370be5cedb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_0dst_0src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and no sources or destinations. </p>

</div>
</div>
<a class="anchor" id="ad3835ac2d78ba9b90e1ced9c58cada5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_0dst_1src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and a single source (<code>src</code>). </p>

</div>
</div>
<a class="anchor" id="a54d0c2cbad95bfe24daade84c6add8af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_0dst_2src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and two sources (<code>src1</code>, <code>src2</code>). </p>

</div>
</div>
<a class="anchor" id="a21033066f65f8dfd23ca24215ea99b70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_0dst_3src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and three sources (<code>src1</code>, <code>src2</code>, <code>src3</code>). </p>

</div>
</div>
<a class="anchor" id="a4db9f5f8dfd216fab6e9153170fb479f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_0src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and one destination (<code>dst</code>). </p>

</div>
</div>
<a class="anchor" id="a0202b3cf63b50d16947f6be6f2b00891"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_1src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, one destination(<code>dst</code>), and one source (<code>src</code>). </p>

</div>
</div>
<a class="anchor" id="ac469b18246e67b23f758c636f460d8ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_2src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, one destination (<code>dst</code>), and two sources (<code>src1</code>, <code>src2</code>). </p>

</div>
</div>
<a class="anchor" id="a4a34019f73e797090b3ab9625cdbc5fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_3src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, one destination (<code>dst</code>), and three sources (<code>src1</code>, <code>src2</code>, <code>src3</code>). </p>

</div>
</div>
<a class="anchor" id="a4e5a5241276ad8d2f392c7a1432efb61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_5src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, one destination (<code>dst</code>), and five sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>, <code>src5</code>). </p>

</div>
</div>
<a class="anchor" id="aeadd422dcd43564d40b43ca0e03b6910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_0src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and no sources. </p>

</div>
</div>
<a class="anchor" id="ae6d0c6211ec93379e4ad6dc520506111"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_1src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and one source (<code>src</code>). </p>

</div>
</div>
<a class="anchor" id="a3c614653cadce1e2e6e567f3f68de6a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_2src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and two sources (<code>src1</code>, <code>src2</code>). </p>

</div>
</div>
<a class="anchor" id="a711cac2989e3f2fa8fa702ce3b7f8ced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_3src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and three sources (<code>src1</code>, <code>src2</code>, <code>src3</code>). </p>

</div>
</div>
<a class="anchor" id="a608e02e275eb868cd09ba8c454d78b5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_4src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and four sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>). </p>

</div>
</div>
<a class="anchor" id="a678839fc8b937d70b63be5fcbbb2d014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_3dst_0src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, three destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>) and no sources. </p>

</div>
</div>
<a class="anchor" id="ae5f963b19ebe6ff70c0ea8174b53d9ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_3dst_3src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, three destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>) and three sources (<code>src1</code>, <code>src2</code>, <code>src3</code>). </p>

</div>
</div>
<a class="anchor" id="a32078373abe0c5fb3f97774a936569d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_3dst_4src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, three destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>) and four sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>). </p>

</div>
</div>
<a class="anchor" id="aee21bbcad5d7ee35f8828ed5244132fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_3dst_5src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, three destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>) and five sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>, <code>src5</code>). </p>

</div>
</div>
<a class="anchor" id="ab8b00a25f7ec49fbf943df0e9c667136"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_4dst_1src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, four destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>, <code>dst4</code>) and 1 source (<code>src</code>). </p>

</div>
</div>
<a class="anchor" id="abd02600b967d24951bc7208b6d70d459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_4dst_4src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, four destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>, <code>dst4</code>) and four sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>). </p>

</div>
</div>
<a class="anchor" id="aa554f82d7fa8abd4f38dba90544c20ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_popa </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> for OP_popa. </p>

</div>
</div>
<a class="anchor" id="a418865307bd5bd168cbde4ecd0f785a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_pusha </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> for OP_pusha. </p>

</div>
</div>
<a class="anchor" id="acb082bbf9ac73968667b79b4cd14d73f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs <a class="el" href="dr__ir__instr_8h.html#ae0f3cc7fb91265cb6c8eb15a84184c1f">instr_free()</a> and then deallocates the thread-local heap storage for <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a6baf5239817b639791916f3cbd6c7b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_disassemble </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>outfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the instruction <code>instr</code> to file <code>outfile</code>. Does not print address-size or data-size prefixes for other than just-decoded instrs, and does not check that the instruction has a valid encoding. Prints each operand with leading zeros indicating the size. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. </p>

</div>
</div>
<a class="anchor" id="af67ded4a34cef770ecc35e24e61813c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t instr_disassemble_to_buffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the instruction <code>instr</code> to the buffer <code>buf</code>. Always null-terminates, and will not print more than <code>bufsz</code> characters, which includes the final null character. Returns the number of characters printed, not including the final null.</p>
<p>Does not print address-size or data-size prefixes for other than just-decoded instrs, and does not check that the instruction has a valid encoding. Prints each operand with leading zeros indicating the size. The default is to use AT&amp;T-style syntax, unless the <a class="el" href="using.html#op_syntax_intel">-syntax_intel</a> runtime option is specified. </p>

</div>
</div>
<a class="anchor" id="a1cd4d0740eb0a0bcd2d387685719263c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* instr_encode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes <code>instr</code> into the memory at <code>pc</code>. Uses the x86/x64 mode stored in instr, not the mode of the current thread. Returns the pc after the encoded instr, or NULL if the encoding failed. If instr is a cti with an <a class="el" href="structinstr__t.html">instr_t</a> target, the note fields of instr and of the target must be set with the respective offsets of each instr_t! (instrlist_encode does this automatically, if the target is in the list). x86 instructions can occupy up to 17 bytes, so the caller should ensure the target location has enough room to avoid overflow. </p>

</div>
</div>
<a class="anchor" id="a5356c2dd3388496158fa0a918f8c2a53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* instr_encode_to_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>final_pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes <code>instr</code> into the memory at <code>copy_pc</code> in preparation for copying to <code>final_pc</code>. Any pc-relative component is encoded as though the instruction were located at <code>final_pc</code>. This allows for direct copying of the encoded bytes to <code>final_pc</code> without re-relativization.</p>
<p>Uses the x86/x64 mode stored in instr, not the mode of the current thread. Returns the pc after the encoded instr, or NULL if the encoding failed. If instr is a cti with an <a class="el" href="structinstr__t.html">instr_t</a> target, the note fields of instr and of the target must be set with the respective offsets of each instr_t! (instrlist_encode does this automatically, if the target is in the list). x86 instructions can occupy up to 17 bytes, so the caller should ensure the target location has enough room to avoid overflow. </p>

</div>
</div>
<a class="anchor" id="ae0f3cc7fb91265cb6c8eb15a84184c1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocates all memory that was allocated by <code>instr</code>. This includes raw bytes allocated by <a class="el" href="dr__ir__instr_8h.html#af7b33f34d4dd11993224b4fb10e136dc">instr_allocate_raw_bits()</a> and operands allocated by <a class="el" href="dr__ir__instr_8h.html#aee0d80a8e69e8f0abe867f1903a107ea">instr_set_num_opnds()</a>. Does not deallocate the storage for <code>instr</code> itself. </p>

</div>
</div>
<a class="anchor" id="aa7af19aa3aadf7b05900a39ef62b01b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_free_raw_bits </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code>instr</code> has raw bits allocated, frees them. </p>

</div>
</div>
<a class="anchor" id="a57dbc129ab88dfdcf49f1105eba394a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc instr_get_app_pc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the original application PC of <code>instr</code> if it exists. </p>

</div>
</div>
<a class="anchor" id="a23aa72462b20fa6349d2ca2289c0f9a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_get_arith_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>instr's</code> arithmetic flags (bottom 6 eflags) use as EFLAGS_ constants or'ed together. If <code>instr's</code> eflags behavior has not been calculated yet or is invalid, the entire eflags use is calculated and returned (not just the arithmetic flags). </p>

</div>
</div>
<a class="anchor" id="ab4c178ef16a57aa4c89976cb11419719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc instr_get_branch_target_pc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>cti_instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the taken target pc of the (direct branch) instruction. </p>

</div>
</div>
<a class="anchor" id="aed999847d48a5a9eb1032239a660e398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopnd__t.html">opnd_t</a> instr_get_dst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>instr's</code> destination operand at position <code>pos</code> (0-based). </p>

</div>
</div>
<a class="anchor" id="af295aa1b99e3b1fb73562312fc547ce9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_get_eflags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>instr's</code> eflags use as EFLAGS_ constants or'ed together. </p>

</div>
</div>
<a class="anchor" id="a784fcd66cdda36aaf218121f1b75ab2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_get_interrupt_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr's</code> opcode is OP_int and that either <code>instr's</code> operands or its raw bits are valid. Returns the first source operand if <code>instr's</code> operands are valid, else if <code>instr's</code> raw bits are valid returns the first raw byte. </p>

</div>
</div>
<a class="anchor" id="a7eab5eaa85e186349d200a87e8010fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__ir__instr_8h.html#af29c184442681322a7a77ab2a48ba889">dr_instr_label_data_t</a>* instr_get_label_data_area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to user-controlled data fields in a label instruction. These fields are available for use by clients for their own purposes. Returns NULL if <code>instr</code> is not a label instruction. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>These data fields are copied (shallowly) across <a class="el" href="dr__ir__instr_8h.html#af8c874bf0f8b67dd6a85f2d54c1e87dc">instr_clone()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a11b5b0700f7601087e2fda87175040"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE <a class="el" href="structinstr__t.html">instr_t</a>* instr_get_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the next <a class="el" href="structinstr__t.html">instr_t</a> in the instrlist_t that contains <code>instr</code>. </p>
<dl class="section note"><dt>Note</dt><dd>The next pointer for an <a class="el" href="structinstr__t.html">instr_t</a> is inside the <a class="el" href="structinstr__t.html">instr_t</a> data structure itself, making it impossible to have on <a class="el" href="structinstr__t.html">instr_t</a> in two different InstrLists (but removing the need for an extra data structure for each element of the instrlist_t). </dd></dl>

</div>
</div>
<a class="anchor" id="a1114903afc8f9a3539aed43330117627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE <a class="el" href="structinstr__t.html">instr_t</a>* instr_get_next_app </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the next application (non-meta) instruction in the instruction list that contains <code>instr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>As opposed to <a class="el" href="dr__ir__instr_8h.html#a9a11b5b0700f7601087e2fda87175040">instr_get_next()</a>, this routine skips all meta instructions inserted by either DynamoRIO or its clients.</dd>
<dd>
We do recommend using this routine during the phase of application code analysis, as any meta instructions present are guaranteed to be ok to skip. However, the caution should be exercised if using this routine after any instrumentation insertion has already happened, as instrumentation might affect register usage or other factors being analyzed. </dd></dl>

</div>
</div>
<a class="anchor" id="a776a1fd0cf8f783b2a969a24432fee6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE void* instr_get_note </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the value of the user-controlled note field in <code>instr</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Important: is also used when emitting for targets that are other instructions. Thus it will be overwritten when calling <a class="el" href="dr__ir__instrlist_8h.html#aaac5ae2bc9af179b56bbbe5efc14e8b5">instrlist_encode()</a> or <a class="el" href="dr__ir__instrlist_8h.html#a8ae48a113e137b95cd3499f9fa57f5ea">instrlist_encode_to_copy()</a> with <code>has_instr_jmp_targets</code> set to true. </dd>
<dd>
The note field is copied (shallowly) by <a class="el" href="dr__ir__instr_8h.html#af8c874bf0f8b67dd6a85f2d54c1e87dc">instr_clone()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a90d36984352b073089da3c91b901c853"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_get_opcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>instr's</code> opcode (an OP_ constant). </p>

</div>
</div>
<a class="anchor" id="a749df373b340acb6437fea2f02b2fe69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_get_opcode_eflags </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the eflags usage of instructions with opcode <code>opcode</code>, as EFLAGS_ constants or'ed together. </p>

</div>
</div>
<a class="anchor" id="a3722cd7a5b3728b5edeefd4b07bd456c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_get_prefix_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>prefix</code> is a PREFIX_ constant. Returns true if <code>instr's</code> prefixes contain the flag <code>prefix</code>. </p>

</div>
</div>
<a class="anchor" id="a1432bded4f063c3c9d41f1a798f703b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE <a class="el" href="structinstr__t.html">instr_t</a>* instr_get_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the previous <a class="el" href="structinstr__t.html">instr_t</a> in the instrlist_t that contains <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a964928ee44090aba9aef343c5d34df5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* instr_get_raw_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid. Returns a pointer to <code>instr's</code> raw bits. </p>
<dl class="section note"><dt>Note</dt><dd>A freshly-decoded instruction has valid raw bits that point to the address from which it was decoded. However, for instructions presented in the basic block or trace events, use <a class="el" href="dr__ir__instr_8h.html#a57dbc129ab88dfdcf49f1105eba394a7">instr_get_app_pc()</a> to retrieve the corresponding application address, as the raw bits will not be set for instructions added after decoding, and may point to a different location for insructions that have been modified. </dd></dl>

</div>
</div>
<a class="anchor" id="af8d41e2a8da7c0ef207d269020053ecc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte instr_get_raw_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and have &gt; <code>pos</code> bytes. Returns a pointer to <code>instr's</code> raw byte at position <code>pos</code> (beginning with 0). </p>

</div>
</div>
<a class="anchor" id="ae0d1b19bf4e736c6f361164a295160a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_get_raw_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and have &gt; <code>pos</code> + 3 bytes. Returns the 4 bytes beginning at position <code>pos</code> (0-based). </p>

</div>
</div>
<a class="anchor" id="ae9e4c9cbe4890f8e37af9e299affc86c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_get_rel_addr_dst_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If any of <code>instr's</code> destination operands is a rip-relative memory reference, returns the operand position. If there is no such destination operand, returns -1.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a8942eef70af97b8018b31df431ef1822"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_get_rel_addr_src_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If any of <code>instr's</code> source operands is a rip-relative memory reference, returns the operand position. If there is no such source operand, returns -1.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a19b43ab8c3edd905329429075e91ea1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_get_rel_addr_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If any of <code>instr's</code> operands is a rip-relative memory reference, returns the address that reference targets. Else returns false.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="aa60219f08461b9bc143214c937893d98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopnd__t.html">opnd_t</a> instr_get_src </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>instr's</code> source operand at position <code>pos</code> (0-based). </p>

</div>
</div>
<a class="anchor" id="a6ff26384b57a52838dbd9b854db44cb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopnd__t.html">opnd_t</a> instr_get_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>cti_instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>cti_instr</code> is a control transfer instruction Returns the first source operand of <code>cti_instr</code> (its target). </p>

</div>
</div>
<a class="anchor" id="acf3a5a5abd40c0c0694f037fcfac5705"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_get_x86_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <code>instr</code> is an x86 instruction (32-bit) and false if <code>instr</code> is an x64 instruction (64-bit).</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="add5ea7e7d0387d7d1461830c1e5253c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_has_allocated_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> has its own allocated memory for raw bits. </p>

</div>
</div>
<a class="anchor" id="a7c2b7bfe6c9670ac127a24ea7aef33d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_has_rel_addr_reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff any of <code>instr's</code> operands is a rip-relative memory reference.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a77b55daa2b3780d2c07e33b8330b2f62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes <code>instr</code>. Sets the x86/x64 mode of <code>instr</code> to the mode of dcontext. </p>

</div>
</div>
<a class="anchor" id="acc25aa34b90fcf0cdcfdbd8028464274"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_invert_cbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> is a conditional branch instruction Reverses the logic of <code>instr's</code> conditional e.g., changes OP_jb to OP_jnb. Works on cti_short_rewrite as well. </p>

</div>
</div>
<a class="anchor" id="a5e6d7eea24e55c4a4851ab4e3c0aa108"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE bool instr_is_app </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff <code>instr</code> is an application (non-meta) instruction (see <a class="el" href="dr__ir__instr_8h.html#ab7d47ceb0c0c0b5f50b78346c85a7f47">instr_set_app()</a> for more information). </p>

</div>
</div>
<a class="anchor" id="a9d347723617986e9424b042cb69495e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_call, OP_call_far, OP_call_ind, or OP_call_far_ind. </p>

</div>
</div>
<a class="anchor" id="a5cb0fc26f65991c24002df14abb7e461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_call_direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_call or OP_call_far. </p>

</div>
</div>
<a class="anchor" id="a1fe1cc575e2870720ceee8ce134771f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_call_indirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_call_ind or OP_call_far_ind. </p>

</div>
</div>
<a class="anchor" id="a006c261a813d4e91fc25c549e5ebbb8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a conditional branch: OP_jcc, OP_jcc_short, OP_loop*, or OP_jecxz. </p>

</div>
</div>
<a class="anchor" id="a076d0445255d4902181cb272bacd80aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a control transfer instruction of any kind This includes OP_jcc, OP_jcc_short, OP_loop*, OP_jecxz, OP_call*, and OP_jmp*. </p>

</div>
</div>
<a class="anchor" id="a4af759611c486c5ac9e1a5336a809661"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cti_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is one of OP_loop* or OP_jecxz. </p>

</div>
</div>
<a class="anchor" id="a2782471943558d57296b89a3f41a530d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cti_short </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a control transfer instruction that takes an 8-bit offset: OP_loop*, OP_jecxz, OP_jmp_short, or OP_jcc_short </p>

</div>
</div>
<a class="anchor" id="a8c61714f2632d46211d61ebb55d4bbde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cti_short_rewrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_loop* or OP_jecxz and instr has been transformed to a sequence of instruction that will allow a 32-bit offset. If <code>pc</code> != NULL, <code>pc</code> is expected to point the the beginning of the encoding of <code>instr</code>, and the following instructions are assumed to be encoded in sequence after <code>instr</code>. Otherwise, the encoding is expected to be found in <code>instr's</code> allocated bits. </p>

</div>
</div>
<a class="anchor" id="a56419903595cc4bd2bb39f887a5275d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_encoding_possible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> can be encoding as a valid IA-32 instruction. </p>

</div>
</div>
<a class="anchor" id="ad7abc869b82542e5ea0e564ec671b7cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_exit_cti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a conditional branch, unconditional branch, or indirect branch with a program address target (NOT an <a class="el" href="structinstr__t.html">instr_t</a> address target) and <code>instr</code> is ok to mangle. </p>

</div>
</div>
<a class="anchor" id="ac83165c08bdab6b1bf0933bccba7d557"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_far_abs_cti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <code>instr</code> is an absolute call or jmp that is far. </p>

</div>
</div>
<a class="anchor" id="a45ee0433816dfcfbe8ca41988d757aee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_far_cti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a far control transfer instruction: OP_jmp_far, OP_call_far, OP_jmp_far_ind, OP_call_far_ind, OP_ret_far, or OP_iret. </p>

</div>
</div>
<a class="anchor" id="a81cdb64c78235caf707130680d1f156d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_floating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a floating point instruction. </p>

</div>
</div>
<a class="anchor" id="ac609abca95ab7f30d7f289f5dd19fdad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_floating_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beb">dr_fp_type_t</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a floating point instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instr</td><td>The instruction to query </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>If the return value is true and <code>type</code> is non-NULL, the type of the floating point operation is written to <code>type</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa21d0c15479e3a0ee88a7ec06fe9eb22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff <code>instr's</code> opcode is OP_int, OP_into, or OP_int3. </p>

</div>
</div>
<a class="anchor" id="ae61355d1ac416d4f04ed286eebc7c251"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_label </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a label meta-instruction. </p>

</div>
</div>
<a class="anchor" id="a963ac2677038071fc295b3b6eb45ce1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a multi-way (indirect) branch: OP_jmp_ind, OP_call_ind, OP_ret, OP_jmp_far_ind, OP_call_far_ind, OP_ret_far, or OP_iret. </p>

</div>
</div>
<a class="anchor" id="ad03f60b3110fcbd793381245bed502be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE bool instr_is_meta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff <code>instr</code> is a meta instruction (see <a class="el" href="dr__ir__instr_8h.html#ad0919782b67d3918ec6feb838e373f15">instr_set_meta()</a> for more information). </p>

</div>
</div>
<a class="anchor" id="a954715b40fa2668d7cde0c4a1bf47e51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_meta_may_fault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff <code>instr</code> is not a meta-instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#a94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault()</a> for more information).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Any meta instruction can fault if it has a non-NULL translation field and the client fully handles all of its faults, so this routine is no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e297cd513cbde904d0e09b721f1e9c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mmx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is part of Intel's MMX instructions. </p>

</div>
</div>
<a class="anchor" id="a8b39dade5681d6135379a5d53fe57512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mov </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is an IA-32/AMD64 "mov" instruction: either OP_mov_st, OP_mov_ld, OP_mov_imm, OP_mov_seg, or OP_mov_priv. </p>

</div>
</div>
<a class="anchor" id="ac8da7990fa33f321134102323546516b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mov_constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_int_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to identify common cases of moving a constant into either a register or a memory address. Returns true and sets <code>*value</code> to the constant being moved for the following cases: mov_imm, mov_st, and xor where the source equals the destination. </p>

</div>
</div>
<a class="anchor" id="a1cf18b53c422fdb11efe7bdcc596aea2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mov_imm_to_tos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a "mov $imm -&gt; (%esp)". </p>

</div>
</div>
<a class="anchor" id="a87d172e2621d4548fe2c414fb0ed333a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_near_call_direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_call. </p>

</div>
</div>
<a class="anchor" id="ab5541d2b9311f842c43c0cfca020eb5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_near_ubr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a near unconditional direct branch: OP_jmp, or OP_jmp_short. </p>

</div>
</div>
<a class="anchor" id="acb2c91a7868ad6a8e5c47af985edde61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_nop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <code>instr</code> is one of a class of common nops. currently checks:</p>
<ul>
<li>nop</li>
<li>nop reg/mem</li>
<li>xchg reg, reg</li>
<li>mov reg, reg</li>
<li>lea reg, (reg) </li>
</ul>

</div>
</div>
<a class="anchor" id="aa653a23cf2029fc4eeaf05eb7523849d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_prefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a prefetch instruction: OP_prefetchnta, OP_prefetchnt0, OP_prefetchnt1, OP_prefetchnt2, OP_prefetch, or OP_prefetchw. </p>

</div>
</div>
<a class="anchor" id="ade184d50e1016f220a10f40a60a4f8ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_ret, OP_ret_far, or OP_iret. </p>

</div>
</div>
<a class="anchor" id="a33bb11334437a3076fbb81c0493f6e7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_sse_or_sse2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is part of Intel's SSE or SSE2 instructions. </p>

</div>
</div>
<a class="anchor" id="a86d982227aea8aa8647694b35cc592b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_syscall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is used to implement system calls: OP_int with a source operand of 0x80 on linux or 0x2e on windows, or OP_sysenter, or OP_syscall, or <a class="el" href="dr__ir__instr_8h.html#a4a4d5454f266483029bd88e5a17e398c">instr_is_wow64_syscall()</a> for WOW64. </p>

</div>
</div>
<a class="anchor" id="ac39c368adab3332628a34c1f48afc466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_ubr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is an unconditional direct branch: OP_jmp, OP_jmp_short, or OP_jmp_far. </p>

</div>
</div>
<a class="anchor" id="a465cc4935f184c4d224afbb9547a445c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_undefined </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is an "undefined" instruction (ud2) </p>

</div>
</div>
<a class="anchor" id="a4a4d5454f266483029bd88e5a17e398c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_wow64_syscall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is the indirect transfer from the 32-bit ntdll.dll to the wow64 system call emulation layer. This instruction will also return true for instr_is_syscall, as well as appear as an indirect call, so clients modifying indirect calls may want to avoid modifying this type.</p>
<dl class="section note"><dt>Note</dt><dd>Windows-only </dd></dl>

</div>
</div>
<a class="anchor" id="a79a9b2a0b21a18dbfd0a7a534204b92b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_jcc_taken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&#160;</td>
          <td class="paramname"><em>eflags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given <code>eflags</code>, returns whether or not the conditional branch, <code>instr</code>, would be taken. </p>

</div>
</div>
<a class="anchor" id="ace0e57a48576a4aac25b1554f6ebcbf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_length </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of <code>instr</code>. As a side effect, if instr_is_app(instr) and <code>instr's</code> raw bits are invalid, encodes <code>instr</code> into bytes allocated with <a class="el" href="dr__ir__instr_8h.html#af7b33f34d4dd11993224b4fb10e136dc">instr_allocate_raw_bits()</a>, after which instr is marked as having valid raw bits. </p>

</div>
</div>
<a class="anchor" id="a8620fe9a0391247fcd9183e7cac291c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_make_persistent </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calling this function with <code>instr</code> makes it safe to keep the instruction around indefinitely when its raw bits point into the cache. The function allocates memory local to <code>instr</code> to hold a copy of the raw bits. If this was not done, the original raw bits could be deleted at some point. Making an instruction persistent is necessary if you want to keep it beyond returning from the call that produced the instruction. </p>

</div>
</div>
<a class="anchor" id="af679a00bb888cbb46ae266a8591997ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_mem_usage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns number of bytes of heap used by <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a67563b7baa993aa824ba1803562fc029"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_memory_reference_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the size, in bytes, of the memory read or write of <code>instr</code>. If <code>instr</code> does not reference memory, or is invalid, returns 0. If <code>instr</code> is a repeated string instruction, considers only one iteration. If <code>instr</code> uses vector addressing (VSIB, introduced in AVX2), considers only the size of each separate memory access. </p>

</div>
</div>
<a class="anchor" id="adb8c87b75de66fe9fcdf3db864a08702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_needs_encoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> raw bits are not a valid encoding of <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a41c99383d4ffa44c28d6fed33b449b2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE int instr_num_dsts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of destination operands of <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a2f43bb8dee8ee7c8d07727247d3428b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE int instr_num_srcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of source operands of <code>instr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Addressing registers used in destination memory references (i.e., base, index, or segment registers) are not separately listed as source operands. </dd></dl>

</div>
</div>
<a class="anchor" id="a221092e79cb7fd9a701c2e260685a6dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_ok_to_emit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff <code>instr</code> is to be emitted into the cache. </p>

</div>
</div>
<a class="anchor" id="a95454ba978870e70aa6b882155c4dabd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE bool instr_ok_to_mangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff <code>instr</code> is not a meta-instruction (see <a class="el" href="dr__ir__instr_8h.html#ab7d47ceb0c0c0b5f50b78346c85a7f47">instr_set_app()</a> for more information).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd><a class="el" href="dr__ir__instr_8h.html#a5e6d7eea24e55c4a4851ab4e3c0aa108">instr_is_app()</a>/instr_is_meta() should be used instead. </dd></dl>

</div>
</div>
<a class="anchor" id="afeaf6ea858ca81c8b9968e4be43749f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_opcode_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is valid. If the opcode is ever set to other than OP_INVALID or OP_UNDECODED it is assumed to be valid. However, calling <a class="el" href="dr__ir__instr_8h.html#a90d36984352b073089da3c91b901c853">instr_get_opcode()</a> will attempt to decode a valid opcode, hence the purpose of this routine. </p>

</div>
</div>
<a class="anchor" id="a9c820f4c4b82638289cca3c40f1d15c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_operands_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> operands are up to date. </p>

</div>
</div>
<a class="anchor" id="af08de27201e4c64a655e309b47d096c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_raw_bits_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> raw bits are a valid encoding of instr. </p>

</div>
</div>
<a class="anchor" id="a5229b3775a4b2cdaa9aa257a27a0be1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_reads_from_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that reg is a DR_REG_ constant. Returns true iff at least one of instr's operands reads from a register that overlaps reg (checks both source operands and addressing registers used in destination operands).</p>
<p>Returns false for multi-byte nops with an operand using reg. </p>

</div>
</div>
<a class="anchor" id="ae408fe229bea0aa800cddb6b911c0e94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_reads_memory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff any of <code>instr's</code> source operands is a memory reference.</p>
<p>Unlike <a class="el" href="dr__ir__opnd_8h.html#a5ed7af0d7ea648245c8efd77b30d7e69">opnd_is_memory_reference()</a>, this routine conisders the semantics of the instruction and returns false for both multi-byte nops with a memory operand and for the <a class="el" href="dr__ir__opcodes_8h.html#aae05225933a42f81e7c4a9fb286596f9a8e5722f2fffd08c1e03efa408a6a0f55">OP_lea</a> instruction, as they do not really reference the memory. It does return true for prefetch instructions. </p>

</div>
</div>
<a class="anchor" id="a7e0752a69bd5b0331f8e98512ec15c2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_reg_in_dst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> destination operands references <code>reg</code>. </p>

</div>
</div>
<a class="anchor" id="ae1092dee2d8367ca2fec50cba5e632d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_reg_in_src </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> source operands references <code>reg</code>.</p>
<p>Returns false for multi-byte nops with a source operand using reg.</p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="dr__ir__instr_8h.html#a5229b3775a4b2cdaa9aa257a27a0be1a">instr_reads_from_reg()</a> to also consider addressing registers in destination operands. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ff0a9b43777e95bf6932260f4b5cc09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_replace_src_opnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>old_opnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>new_opnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces all instances of <code>old_opnd</code> in <code>instr's</code> source operands with <code>new_opnd</code> (uses <a class="el" href="dr__ir__opnd_8h.html#adabfafe5e90003ff8e05775beef1f283">opnd_same()</a> to detect sameness). </p>

</div>
</div>
<a class="anchor" id="accd2bdee07d2e6ca0be3b252bc7b913f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_reset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs both <a class="el" href="dr__ir__instr_8h.html#ae0f3cc7fb91265cb6c8eb15a84184c1f">instr_free()</a> and <a class="el" href="dr__ir__instr_8h.html#a77b55daa2b3780d2c07e33b8330b2f62">instr_init()</a>. <code>instr</code> must have been initialized. </p>

</div>
</div>
<a class="anchor" id="ab9b44a1db49dc5cd8da8b6b27fa47d50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_reuse </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees all dynamically allocated storage that was allocated by <code>instr</code>, except for allocated bits. Also zeroes out <code>instr's</code> fields, except for raw bit fields, whether <code>instr</code> is <a class="el" href="dr__ir__instr_8h.html#ad03f60b3110fcbd793381245bed502be">instr_is_meta()</a>, and the x86 mode of <code>instr</code>. <code>instr</code> must have been initialized. </p>

</div>
</div>
<a class="anchor" id="a9e75c7fe47cb20acfae6bca1cd4bd2e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_same </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr1</code> and <code>instr2</code> have the same opcode, prefixes, and source and destination operands (uses <a class="el" href="dr__ir__opnd_8h.html#adabfafe5e90003ff8e05775beef1f283">opnd_same()</a> to compare the operands). </p>

</div>
</div>
<a class="anchor" id="ab7d47ceb0c0c0b5f50b78346c85a7f47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_app </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>instr</code> as an application (non-meta) instruction. An application instruction might be mangled by DR if necessary, e.g., to create an exit stub for a branch instruction. All application instructions that are added to basic blocks or traces should have their translation fields set (via <a class="el" href="dr__ir__instr_8h.html#af1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation()</a>). </p>

</div>
</div>
<a class="anchor" id="a1429cf1d1da8156898fde712e59e86db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_branch_target_pc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>cti_instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the taken target pc of the (direct branch) instruction. </p>

</div>
</div>
<a class="anchor" id="a8e843e39613655f6a5c49e081fe593c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_dst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>opnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>instr's</code> destination operand at position <code>pos</code> to be <code>opnd</code>. Also calls instr_set_raw_bits_valid(<code>instr</code>, false) and instr_set_operands_valid(<code>instr</code>, true). </p>

</div>
</div>
<a class="anchor" id="ad0919782b67d3918ec6feb838e373f15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_meta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>instr</code> as a meta instruction. A meta instruction will not be mangled by DR in any way, which is necessary to have DR not create an exit stub for a branch instruction. Meta instructions should not fault (unless such faults are handled by the client) and are not considered application instructions but rather added instrumentation code (see <a class="el" href="dr__events_8h.html#a043a3588c4cf0c2d6838140fce530e72">dr_register_bb_event()</a> for further information). </p>

</div>
</div>
<a class="anchor" id="a94227a193446d370f0180e6a844be0c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_meta_may_fault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Any meta instruction can fault if it has a non-NULL translation field and the client fully handles all of its faults, so this routine is no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5206d055a5b06435bd5e919da40e8bd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_meta_no_translation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience routine that calls both <a class="el" href="dr__ir__instr_8h.html#ad0919782b67d3918ec6feb838e373f15">instr_set_meta</a> (instr) and <a class="el" href="dr__ir__instr_8h.html#af1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation</a> (instr, NULL). </p>

</div>
</div>
<a class="anchor" id="aa8c3ae1eb25b05c337889022f35e6187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE void instr_set_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the next field of <code>instr</code> to point to <code>next</code>. </p>

</div>
</div>
<a class="anchor" id="a85a8f92faa0d368fec240e6fa819ca9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE void instr_set_note </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the user-controlled note field in <code>instr</code> to <code>value</code>. </p>

</div>
</div>
<a class="anchor" id="aee0d80a8e69e8f0abe867f1903a107ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_num_opnds </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_srcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> has been initialized but does not have any operands yet. Allocates storage for <code>num_srcs</code> source operands and <code>num_dsts</code> destination operands. </p>

</div>
</div>
<a class="anchor" id="ae34605a2cff286d358941be6aa91788d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_ok_to_emit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set <code>instr</code> to "ok to emit" if <code>val</code> is true and "not ok to emit" if <code>val</code> is false. An instruction that should not be emitted is treated normally by DR for purposes of exits but is not placed into the cache. It is used for final jumps that are to be elided. </p>

</div>
</div>
<a class="anchor" id="a2335bd8d05936e8308506ef11f1be401"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_ok_to_mangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>instr</code> to "ok to mangle" if <code>val</code> is true and "not ok to
mangle" if <code>val</code> is false.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd><a class="el" href="dr__ir__instr_8h.html#ab7d47ceb0c0c0b5f50b78346c85a7f47">instr_set_app()</a>/instr_set_meta() should be used instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e1efc53088af35fa0ed6eefd80af5dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_opcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes <code>opcode</code> is an OP_ constant and sets it to be instr's opcode. </p>

</div>
</div>
<a class="anchor" id="ac8f4d5f068f69df848c0dd1cacebc90f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_operands_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>instr's</code> operands to be valid if <code>valid</code> is true, invalid otherwise. </p>

</div>
</div>
<a class="anchor" id="a3948b6ce886753002699286061faef26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_set_prefix_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>prefix</code> is a PREFIX_ constant. Ors <code>instr's</code> prefixes with <code>prefix</code>. Returns the supplied instr (for easy chaining). </p>

</div>
</div>
<a class="anchor" id="a208fe2bdba4a5ea47f1a0588fdc3278b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE void instr_set_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the prev field of <code>instr</code> to point to <code>prev</code>. </p>

</div>
</div>
<a class="anchor" id="a7b9c3a55529a9e5467851821fe53fdb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> does not currently have any raw bits allocated. Sets <code>instr's</code> raw bits to be <code>length</code> bytes starting at <code>addr</code>. Does not set the operands invalid. </p>

</div>
</div>
<a class="anchor" id="a76b3326d827b06a1d1d0bc3d20ba17a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_bits_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>instr's</code> raw bits to be valid if <code>valid</code> is true, invalid otherwise. </p>

</div>
</div>
<a class="anchor" id="ad11045a1b7b7cbd2053048f028e5e687"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and allocated by <code>instr</code> and have &gt; <code>pos</code> bytes. Sets instr's raw byte at position <code>pos</code> (beginning with 0) to the value <code>byte</code>. </p>

</div>
</div>
<a class="anchor" id="a71fba42e58fa08ed1e0da9be2fbde4d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and allocated by <code>instr</code> and have &gt;= num_bytes bytes. Copies the <code>num_bytes</code> beginning at start to <code>instr's</code> raw bits. </p>

</div>
</div>
<a class="anchor" id="a22ea2d9c35a7b4fcf89e4d160314babb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and allocated by <code>instr</code> and have &gt; pos+3 bytes. Sets the 4 bytes beginning at position <code>pos</code> (0-based) to the value word. </p>

</div>
</div>
<a class="anchor" id="a96bfa15e2f3a95174e36c80c585a24e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_src </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>opnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>instr's</code> source operand at position <code>pos</code> to be <code>opnd</code>. Also calls instr_set_raw_bits_valid(<code>instr</code>, false) and instr_set_operands_valid(<code>instr</code>, true). </p>

</div>
</div>
<a class="anchor" id="adbf4b84b7a6b07e22af66b0aec7cacf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>cti_instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>cti_instr</code> is a control transfer instruction. Sets the first source operand of <code>cti_instr</code> to be <code>target</code>. Also calls instr_set_raw_bits_valid(<code>instr</code>, false) and instr_set_operands_valid(<code>instr</code>, true). </p>

</div>
</div>
<a class="anchor" id="af1beda2d570ba04d74ca9cbd7c31bb1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_set_translation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the translation pointer for <code>instr</code>, used to recreate the application address corresponding to this instruction. When adding or modifying instructions that are to be considered application instructions (i.e., non meta-instructions: see <a class="el" href="dr__ir__instr_8h.html#a5e6d7eea24e55c4a4851ab4e3c0aa108">instr_is_app</a>), the translation should always be set. Pick the application address that if executed will be equivalent to restarting <code>instr</code>. Currently the translation address must lie within the existing bounds of the containing code block. Returns the supplied <code>instr</code> (for easy chaining). Use <a class="el" href="dr__ir__instr_8h.html#a57dbc129ab88dfdcf49f1105eba394a7">instr_get_app_pc</a> to see the current value of the translation. </p>

</div>
</div>
<a class="anchor" id="a74814111812ff20b281f7350fb626746"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_x86_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>x86</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each instruction stores whether it should be interpreted in 32-bit (x86) or 64-bit (x64) mode. This routine sets the mode for <code>instr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dba2c8ede2bb35a708bd8dba95d5746"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_shrink_to_16_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shrinks all registers not used as addresses, and all immed integer and address sizes, to 16 bits. Does not shrink DR_REG_ESI or DR_REG_EDI used in string instructions. </p>

</div>
</div>
<a class="anchor" id="ae0db1cec99a6fff7dde7201a87ca8892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_shrink_to_32_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shrinks all registers, including addresses, and all immed integer and address sizes, to 32 bits.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b828bdfc3723d5b05d7147cfc237397"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_uses_fp_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff at least one of <code>instr's</code> operands references a floating point register. </p>

</div>
</div>
<a class="anchor" id="a15a3336a497835085cc0a7be3b010cf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_uses_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> operands references a register that overlaps <code>reg</code>.</p>
<p>Returns false for multi-byte nops with an operand using reg. </p>

</div>
</div>
<a class="anchor" id="a9890dc9d4dbc40589c974a0ff221db72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is NOT OP_INVALID. Not to be confused with an invalid opcode, which can be OP_INVALID or OP_UNDECODED. OP_INVALID means an instruction with no valid fields: raw bits (may exist but do not correspond to a valid instr), opcode, eflags, or operands. It could be an uninitialized instruction or the result of decoding an invalid sequence of bytes. </p>

</div>
</div>
<a class="anchor" id="ae1aac8cef8bb6ab075238e38ad6888a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_writes_memory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff any of <code>instr's</code> destination operands is a memory reference. </p>

</div>
</div>
<a class="anchor" id="a2d5a8131ed782adc6f31471417b88da9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_writes_to_exact_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> destination operands is the same register (not enough to just overlap) as <code>reg</code>. </p>

</div>
</div>
<a class="anchor" id="a2b2d116d97b3cbb47895984077119cfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_writes_to_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_id_t&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> destination operands is a register operand for a register that overlaps <code>reg</code>. </p>

</div>
</div>
<a class="anchor" id="a785671aba1adec0f47add596f7e6a440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_zeroes_ymmh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> writes to an xmm register and zeroes the top half of the corresponding ymm register as a result (some instructions preserve the top half while others zero it when writing to the bottom half). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_87d0e4dd236e354ebe37d9465555a8e6.html">include</a></li><li class="navelem"><a class="el" href="dr__ir__instr_8h.html">dr_ir_instr.h</a></li>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO API version 5.0.0 --- Wed Sep 10 2014 21:36:18 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
